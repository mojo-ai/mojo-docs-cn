# MojoğŸ”¥ç¼–ç¨‹æ‰‹å†Œ

Mojo æ˜¯ä¸€ç§ä¸ Python ä¸€æ ·æ˜“äºä½¿ç”¨çš„ç¼–ç¨‹è¯­è¨€ï¼Œä½†å…·æœ‰ C++ å’Œ Rust çš„æ€§èƒ½ã€‚æ­¤å¤–ï¼ŒMojo è¿˜æä¾›äº†åˆ©ç”¨æ•´ä¸ª Python åº“ç”Ÿæ€ç³»ç»Ÿçš„èƒ½åŠ›ã€‚

Mojo é€šè¿‡åˆ©ç”¨å…·æœ‰é›†æˆç¼“å­˜ã€å¤šçº¿ç¨‹å’Œäº‘åˆ†å‘æŠ€æœ¯çš„ä¸‹ä¸€ä»£ç¼–è¯‘å™¨æŠ€æœ¯æ¥å®ç°è¿™ä¸€åŠŸèƒ½ã€‚æ­¤å¤–ï¼ŒMojo çš„è‡ªåŠ¨è°ƒæ•´å’Œç¼–è¯‘æ—¶å…ƒç¼–ç¨‹åŠŸèƒ½å…è®¸æ‚¨å°†ç¼–å†™çš„ä»£ç ç§»æ¤åˆ°ä¸åŒç¡¬ä»¶ä¸Šã€‚

æ›´é‡è¦çš„æ˜¯ï¼Œ**Mojo å…è®¸æ‚¨åˆ©ç”¨æ•´ä¸ª Python ç”Ÿæ€ç³»ç»Ÿ**ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ç»§ç»­ä½¿ç”¨æ‚¨ç†Ÿæ‚‰çš„å·¥å…·ã€‚Mojo åœ¨é€šè¿‡ä¿ç•™ Python çš„åŠ¨æ€åŠŸèƒ½åŒæ—¶ï¼Œæ·»åŠ æ–°çš„[ç³»ç»Ÿç¼–ç¨‹](https://en.wikipedia.org/wiki/Systems_programming)åŸè¯­ï¼Œéšç€æ—¶é—´çš„æ¨ç§»æˆä¸º Python çš„**è¶…é›†**ã€‚è¿™äº›æ–°çš„ç³»ç»Ÿç¼–ç¨‹åŸè¯­å°†å…è®¸ Mojo å¼€å‘äººå‘˜æ„å»ºé«˜æ€§èƒ½åº“ï¼Œè¿™äº›åº“ä»¥å‰å¯èƒ½éœ€è¦ Cã€C++ã€Rustã€CUDA å’Œå…¶ä»–åŠ é€Ÿå™¨ç³»ç»Ÿæ„å»ºã€‚é€šè¿‡æ±‡é›†æœ€å¥½çš„åŠ¨æ€è¯­è¨€å’Œç³»ç»Ÿè¯­è¨€ï¼Œæˆ‘ä»¬å¸Œæœ›æä¾›ä¸€ä¸ª**ç»Ÿä¸€çš„**è·¨æŠ½è±¡çº§åˆ«å·¥ä½œçš„ç¼–ç¨‹æ¨¡å‹ï¼Œå¯¹æ–°æ‰‹ç¨‹åºå‘˜å‹å¥½ï¼Œå¹¶ä¸”å¯ä»¥æ‰©å±•åˆ°ä»åŠ é€Ÿå™¨åˆ°åº”ç”¨ç¨‹åºç¼–ç¨‹å’Œè„šæœ¬ç¼–å†™çš„è®¸å¤šç”¨ä¾‹ã€‚

æœ¬æ–‡æ¡£æ˜¯ Mojo ç¼–ç¨‹è¯­è¨€çš„ä»‹ç»ï¼Œè€Œä¸æ˜¯å®Œæ•´çš„è¯­è¨€æŒ‡å—ã€‚å®ƒå‡å®šæ‚¨äº†è§£ Python å’Œç³»ç»Ÿç¼–ç¨‹æ¦‚å¿µã€‚ç›®å‰ï¼ŒMojo ä»åœ¨å¼€å‘ä¸­ï¼Œå…¶æ–‡æ¡£é¢å‘å…·æœ‰ç³»ç»Ÿç¼–ç¨‹ç»éªŒçš„å¼€å‘äººå‘˜ã€‚éšç€è¯¥è¯­è¨€çš„å‘å±•å’Œå˜å¾—æ›´åŠ å¹¿æ³›å¯ç”¨ï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒå¯¹æ¯ä¸ªäººï¼ˆåŒ…æ‹¬åˆå­¦è€…ç¨‹åºå‘˜ï¼‰éƒ½å‹å¥½ä¸”æ˜“äºä½¿ç”¨ã€‚åªæ˜¯ç›®å‰è¿˜ä¸è¡Œã€‚

## [ä½¿ç”¨ Mojo ç¼–è¯‘å™¨](#using-the-mojo-compiler)

ä½¿ç”¨[Mojo SDK](https://docs.modular.com/mojo/manual/get-started/)ï¼Œæ‚¨å¯ä»¥ä»ç»ˆç«¯è¿è¡Œ Mojo ç¨‹åºï¼Œå°±åƒä½¿ç”¨ Python ä¸€æ ·ã€‚å› æ­¤ï¼Œå¦‚æœæ‚¨æœ‰ä¸€ä¸ªåä¸º`hello.mojo`ï¼ˆæˆ–`hello.ğŸ”¥`ï¼Œæ˜¯çš„ï¼Œæ–‡ä»¶æ‰©å±•åå¯ä»¥æ˜¯è¡¨æƒ…ç¬¦å·ï¼ï¼‰çš„æ–‡ä»¶ï¼Œåªéœ€é”®å…¥`mojo hello.mojo`ï¼š

```
$ cat hello.ğŸ”¥
def main():
    print("hello world")
    for x in range(9, 0, -3):
        print(x)
$ mojo hello.ğŸ”¥
hello world
9
6
3
$
```

åŒæ ·ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨`.mojo`æˆ–`.ğŸ”¥`åç¼€ã€‚

æœ‰å…³ Mojo ç¼–è¯‘å™¨å·¥å…·çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…[`mojo`CLI æ–‡æ¡£](https://docs.modular.com/mojo/cli/)ã€‚

## [åŸºæœ¬ç³»ç»Ÿç¼–ç¨‹æ‰©å±•](#basic-systems-programming-extensions)

è€ƒè™‘åˆ°æˆ‘ä»¬çš„å…¼å®¹æ€§ç›®æ ‡ä»¥åŠ Python åœ¨é«˜çº§åº”ç”¨ç¨‹åºå’ŒåŠ¨æ€ API æ–¹é¢çš„ä¼˜åŠ¿ï¼Œæˆ‘ä»¬ä¸å¿…èŠ±è´¹å¤ªå¤šæ—¶é—´æ¥è§£é‡Šè¯¥è¯­è¨€çš„è¿™äº›éƒ¨åˆ†æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚å¦ä¸€æ–¹é¢ï¼ŒPython å¯¹ç³»ç»Ÿç¼–ç¨‹çš„æ”¯æŒä¸»è¦å§”æ‰˜ç»™ Cï¼Œæˆ‘ä»¬å¸Œæœ›æä¾›ä¸€ä¸ªåœ¨è¯¥é¢†åŸŸéå¸¸å‡ºè‰²çš„å•ä¸€ç³»ç»Ÿã€‚å› æ­¤ï¼Œæœ¬èŠ‚è¯¦ç»†ä»‹ç»äº†æ¯ä¸ªä¸»è¦ç»„ä»¶å’ŒåŠŸèƒ½ï¼Œå¹¶é€šè¿‡ç¤ºä¾‹æè¿°äº†å¦‚ä½•ä½¿ç”¨å®ƒä»¬ã€‚

### [`let`å’Œ`var`å£°æ˜](#let-and-var-declarations)

åœ¨ Mojo çš„`def`å†…éƒ¨ï¼Œæ‚¨å¯ä»¥ä¸ºåç§°åˆ†é…ä¸€ä¸ªå€¼ï¼Œå®ƒä¼šéšå¼åˆ›å»ºä¸€ä¸ªå‡½æ•°ä½œç”¨åŸŸå˜é‡ï¼Œå°±åƒåœ¨ Python ä¸­ä¸€æ ·ã€‚è¿™æä¾›äº†ä¸€ç§éå¸¸åŠ¨æ€ä¸”ç®€å•çš„ä»£ç ç¼–å†™æ–¹å¼ï¼Œä½†å®ƒä¹Ÿä¼šé€ æˆä¸€äº›å½±å“ï¼ŒåŸå› æœ‰äºŒï¼š

1. ç³»ç»Ÿç¨‹åºå‘˜é€šå¸¸å¸Œæœ›å£°æ˜ä¸€ä¸ªå€¼æ˜¯ä¸å¯å˜çš„ï¼Œä»¥ä¿è¯ç±»å‹å®‰å…¨å’Œæ€§èƒ½ã€‚
2. å¦‚æœä»–ä»¬åœ¨èµ‹å€¼ä¸­è¾“é”™äº†å˜é‡åï¼Œä»–ä»¬å¯èƒ½å¸Œæœ›å¾—åˆ°ä¸€ä¸ªé”™è¯¯ã€‚

ä¸ºäº†æ”¯æŒè¿™ä¸€ç‚¹ï¼ŒMojo æä¾›äº†ä½œç”¨åŸŸè¿è¡Œæ—¶å€¼å£°æ˜ï¼š`let`æ˜¯ä¸å¯å˜çš„ï¼Œè€Œ`var`æ˜¯å¯å˜çš„ã€‚è¿™äº›å€¼ä½¿ç”¨è¯æ³•ä½œç”¨åŸŸå¹¶æ”¯æŒåç§°è¦†ç›–ï¼š

```
def your_function(a, b):
    let c = a
    # Uncomment to see an error:
    # c = b  # error: c is immutable

    if c != b:
        let d = b
        print(d)

your_function(2, 3)
```

```
3
```

`let`å’Œ`var`å£°æ˜æ”¯æŒç±»å‹è¯´æ˜ã€æ¨¡å¼ä»¥åŠåæœŸåˆå§‹åŒ–ï¼š

```
def your_function():
    let x: Int = 42
    let y: Float64 = 17.0

    let z: Float32
    if x != 0:
        z = 1.0
    else:
        z = foo()
    print(z)

def foo() -> Float32:
    return 3.14

your_function()
```

```
1.0
```

è¯·æ³¨æ„ï¼Œåœ¨`def`å‡½æ•°ä¸­ï¼Œ`let`å’Œ`var`æ˜¯å®Œå…¨å¯é€‰çš„ï¼ˆæ‚¨å¯ä»¥ä½¿ç”¨éšå¼å£°æ˜çš„å€¼ï¼Œå°±åƒ Python ä¸€æ ·ï¼‰ï¼Œä½†å¯¹äº`fn`å‡½æ•°ä¸­çš„æ‰€æœ‰å˜é‡å®ƒä»¬éƒ½æ˜¯å¿…éœ€çš„ã€‚

å¦è¯·æ³¨æ„ï¼Œåœ¨ REPL ç¯å¢ƒï¼ˆä¾‹å¦‚æœ¬ç¬”è®°ï¼‰ä¸­ä½¿ç”¨ Mojo æ—¶ï¼Œé¡¶çº§å˜é‡ï¼ˆä½äºå‡½æ•°æˆ–ç»“æ„ä¹‹å¤–çš„å˜é‡ï¼‰ä¼šè¢«è§†ä¸º`def`ä¸­çš„å˜é‡ï¼Œå› æ­¤å®ƒä»¬å…è®¸éšå¼å€¼ç±»å‹å£°æ˜ï¼ˆå®ƒä»¬ä¸éœ€è¦`var`æˆ–`let`å£°æ˜ï¼Œä¹Ÿä¸æ˜¯ç±»å‹å£°æ˜ï¼‰ã€‚è¿™ä¸ Python REPL è¡Œä¸ºç›¸åŒ¹é…ã€‚

### [`struct`ç±»å‹](#struct-types)

Mojo åŸºäº MLIR å’Œ LLVMï¼Œæä¾›äº†å¤šç§ç¼–ç¨‹è¯­è¨€çš„å°–ç«¯ç¼–è¯‘å™¨å’Œä»£ç ç”Ÿæˆç³»ç»Ÿã€‚å¯ä»¥æ›´å¥½åœ°æ§åˆ¶æ•°æ®ç»„ç»‡ã€ç›´æ¥è®¿é—®æ•°æ®å­—æ®µä»¥åŠæ‹¥æœ‰å…¶ä»–æé«˜æ€§èƒ½çš„æ–¹æ³•ã€‚ç°ä»£ç³»ç»Ÿç¼–ç¨‹è¯­è¨€çš„ä¸€ä¸ªé‡è¦ç‰¹å¾æ˜¯èƒ½å¤Ÿåœ¨è¿™äº›å¤æ‚çš„ä½çº§æ“ä½œä¹‹ä¸Šæ„å»ºé«˜çº§ä¸”å®‰å…¨çš„æŠ½è±¡ï¼Œè€Œä¸ä¼šé€ æˆä»»ä½•æ€§èƒ½æŸå¤±ã€‚åœ¨ Mojo ä¸­ï¼Œè¿™æ˜¯ç”±`struct`ç±»å‹æä¾›çš„ã€‚

Mojo ä¸­çš„`struct`ä¸ Python ç±»ä¼¼`class`ï¼šå®ƒä»¬éƒ½æ”¯æŒæ–¹æ³•ã€å­—æ®µã€è¿ç®—ç¬¦é‡è½½ã€å…ƒç¼–ç¨‹è£…é¥°å™¨ç­‰ã€‚å®ƒä»¬çš„åŒºåˆ«å¦‚ä¸‹ï¼š

* Python ç±»æ˜¯åŠ¨æ€çš„ï¼šå®ƒä»¬å…è®¸åŠ¨æ€è°ƒåº¦ã€çŒ´å­ä¿®è¡¥ï¼ˆæˆ–â€œswizzlingâ€ï¼‰ä»¥åŠåœ¨è¿è¡Œæ—¶åŠ¨æ€ç»‘å®šå®ä¾‹å±æ€§ã€‚
* Mojo ç»“æ„æ˜¯é™æ€çš„ï¼šå®ƒä»¬åœ¨ç¼–è¯‘æ—¶ç»‘å®šï¼ˆä¸èƒ½åœ¨è¿è¡Œæ—¶æ·»åŠ æ–¹æ³•ï¼‰ã€‚ç»“æ„å…è®¸æ‚¨ä»¥çµæ´»æ€§æ¢å–æ€§èƒ½ï¼ŒåŒæ—¶å®‰å…¨ä¸”æ˜“äºä½¿ç”¨ã€‚

è¿™æ˜¯ç»“æ„ä½“çš„ç®€å•å®šä¹‰ï¼š

```
struct MyPair:
    var first: Int
    var second: Int

    # We use 'fn' instead of 'def' here - we'll explain that soon
    fn __init__(inout self, first: Int, second: Int):
        self.first = first
        self.second = second

    fn __lt__(self, rhs: MyPair) -> Bool:
        return self.first < rhs.first or
              (self.first == rhs.first and
               self.second < rhs.second)
```

ä»è¯­æ³•ä¸Šè®²ï¼Œä¸ Python ç›¸æ¯”æœ€å¤§çš„åŒºåˆ«`class`æ˜¯`struct`ä¸­çš„æ‰€æœ‰å®ä¾‹å±æ€§éƒ½ **å¿…é¡»**ä½¿ç”¨`var`ã€`let`å£°æ˜æˆ–ç±»å‹å£°æ˜ã€‚

åœ¨Mojoä¸­ï¼Œ`struct`çš„ç»“æ„å’Œå†…å®¹æ˜¯é¢„å…ˆè®¾ç½®çš„ï¼Œå¹¶ä¸”åœ¨ç¨‹åºè¿è¡Œæ—¶ä¸èƒ½æ›´æ”¹ã€‚ä¸ Python ä¸åŒçš„æ˜¯ï¼Œåœ¨ Python ä¸­æ‚¨å¯ä»¥åŠ¨æ€æ·»åŠ ã€åˆ é™¤æˆ–æ›´æ”¹å¯¹è±¡çš„å±æ€§ï¼Œè€Œ Mojo ä¸å…è®¸å¯¹ç»“æ„è¿›è¡Œè¿™ç§æ“ä½œã€‚è¿™æ„å‘³ç€æ‚¨ä¸èƒ½`del`åœ¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­åˆ é™¤æ–¹æ³•æˆ–æ›´æ”¹å…¶å€¼ã€‚

ç„¶è€Œï¼Œé™æ€ç‰¹æ€§`struct`æœ‰ä¸€äº›å¾ˆå¤§çš„å¥½å¤„ï¼å®ƒå¯ä»¥å¸®åŠ© Mojo æ›´å¿«åœ°è¿è¡Œæ‚¨çš„ä»£ç ã€‚ç¨‹åºç¡®åˆ‡åœ°çŸ¥é“åœ¨å“ªé‡Œå¯ä»¥æ‰¾åˆ°ç»“æ„ä½“çš„ä¿¡æ¯ä»¥åŠå¦‚ä½•ä½¿ç”¨å®ƒï¼Œè€Œæ— éœ€ä»»ä½•é¢å¤–çš„æ­¥éª¤æˆ–å»¶è¿Ÿã€‚

Mojo çš„ç»“æ„ä¹Ÿå¯ä»¥å¾ˆå¥½åœ°ä¸æ‚¨å¯èƒ½å·²ç»ä» Python ä¸­äº†è§£çš„åŠŸèƒ½é…åˆä½¿ç”¨ï¼Œä¾‹å¦‚è¿ç®—ç¬¦é‡è½½ï¼ˆè®©æ‚¨å¯ä»¥æ›´æ”¹ + å’Œ - ç­‰æ•°å­¦ç¬¦å·å¦‚ä½•å¤„ç†æ‚¨è‡ªå·±çš„æ•°æ®ï¼‰ã€‚æ­¤å¤–ï¼Œ_æ‰€æœ‰_â€œæ ‡å‡†ç±»å‹â€ï¼ˆä¾‹å¦‚`Int`ã€`Bool`ã€`String`ç”šè‡³`Tuple`ï¼‰éƒ½æ˜¯ä½¿ç”¨ç»“æ„ä½“åˆ›å»ºçš„ã€‚è¿™æ„å‘³ç€å®ƒä»¬æ˜¯æ‚¨å¯ä»¥ä½¿ç”¨çš„æ ‡å‡†å·¥å…·é›†çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯ç¡¬è¿æ¥åˆ°è¯­è¨€æœ¬èº«ä¸­ã€‚è¿™ä¸ºæ‚¨åœ¨ç¼–å†™ä»£ç æ—¶æä¾›äº†æ›´å¤§çš„çµæ´»æ€§å’Œæ§åˆ¶åŠ›ã€‚

`self`å‚æ•°ä¸­`inout`çš„å«ä¹‰ï¼šè¿™è¡¨æ˜å‚æ•°æ˜¯å¯å˜çš„ï¼Œå¹¶ä¸”å‡½æ•°å†…éƒ¨æ‰€åšçš„æ›´æ”¹å¯¹è°ƒç”¨è€…å¯è§ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…ä¸‹é¢æœ‰å…³[inout Arguments](https://docs.modular.com/mojo/programming-manual.html#mutable-arguments-inout)çš„å†…å®¹ã€‚

#### [`Int`ä¸`int`](#int-vs-int)

åœ¨ Mojo ä¸­ï¼Œæ‚¨å¯èƒ½ä¼šæ³¨æ„åˆ°æˆ‘ä»¬ä½¿ç”¨`Int`ï¼ˆå¤§å†™â€œIâ€ï¼‰ï¼Œè¿™ä¸ Python `int`ï¼ˆå°å†™â€œiâ€ï¼‰ä¸åŒã€‚è¿™ç§å·®å¼‚æ˜¯æ•…æ„çš„ï¼Œè€Œä¸”å®é™…ä¸Šæ˜¯ä¸€ä»¶å¥½äº‹ï¼

åœ¨ Python ä¸­ï¼Œè¯¥`int`ç±»å‹å¯ä»¥å¤„ç†éå¸¸å¤§çš„æ•°å­—ï¼Œå¹¶ä¸”å…·æœ‰ä¸€äº›é¢å¤–çš„åŠŸèƒ½ï¼Œä¾‹å¦‚æ£€æŸ¥ä¸¤ä¸ªæ•°å­—æ˜¯å¦æ˜¯åŒä¸€ä¸ªå¯¹è±¡ã€‚ä½†è¿™å¸¦æ¥äº†ä¸€äº›é¢å¤–çš„è´Ÿæ‹…ï¼Œå¯èƒ½ä¼šå‡æ…¢é€Ÿåº¦ã€‚Mojoçš„`Int`åˆ™ä¸åŒã€‚å®ƒçš„è®¾è®¡ç®€å•ã€å¿«é€Ÿï¼Œå¹¶é’ˆå¯¹æ‚¨çš„è®¡ç®—æœºç¡¬ä»¶è¿›è¡Œäº†è°ƒæ•´ï¼Œä»¥ä¾¿å¿«é€Ÿå¤„ç†ã€‚

è¿™æ ·åšæœ‰ä¸¤ä¸ªä¸»è¦åŸå› ï¼š

1. æˆ‘ä»¬å¸Œæœ›ä¸ºæ·±å…¥ç³»ç»Ÿåº•å±‚ç¡¬ä»¶çš„ç¨‹åºå‘˜ï¼ˆç³»ç»Ÿç¨‹åºå‘˜ï¼‰æä¾›ä¸€ç§é€æ˜ä¸”å¯é çš„ä¸ç¡¬ä»¶äº¤äº’çš„æ–¹å¼ã€‚æˆ‘ä»¬ä¸æƒ³ä¾é èŠ±å“¨çš„æŠ€å·§ï¼ˆæ¯”å¦‚ JIT ç¼–è¯‘å™¨ï¼‰ã€‚
2. æˆ‘ä»¬å¸Œæœ› Mojo èƒ½å¤Ÿä¸ Python å¾ˆå¥½åœ°é…åˆï¼Œè€Œä¸ä¼šå¼•èµ·ä»»ä½•é—®é¢˜ã€‚é€šè¿‡ä½¿ç”¨ä¸åŒçš„åç§°ï¼ˆInt è€Œä¸æ˜¯ intï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ Mojo ä¸­ä¿ç•™è¿™ä¸¤ç§ç±»å‹ï¼Œè€Œæ— éœ€æ›´æ”¹ Python int çš„å·¥ä½œæ–¹å¼ã€‚

ä½œä¸ºå¥–åŠ±ï¼Œ`Int`éµå¾ªçš„å‘½åé£æ ¼ï¼Œä¸æ‚¨å¯èƒ½åœ¨ Mojo ä¸­åˆ›å»ºçš„å…¶ä»–è‡ªå®šä¹‰æ•°æ®ç±»å‹ç›¸åŒã€‚æ­¤å¤–ï¼Œ`Int`æœ¬èº«æ˜¯`struct`ï¼ŒåŒ…å«åœ¨ Mojo çš„æ ‡å‡†å·¥å…·é›†ä¸­ã€‚

### [å¼ºç±»å‹æ£€æŸ¥](#strong-type-checking)

å°½ç®¡æ‚¨ä»ç„¶å¯ä»¥åƒåœ¨ Python ä¸­ä¸€æ ·ä½¿ç”¨çµæ´»çš„ç±»å‹ï¼Œä½† Mojo å…è®¸æ‚¨ä½¿ç”¨ä¸¥æ ¼çš„ç±»å‹æ£€æŸ¥ã€‚ç±»å‹æ£€æŸ¥å¯ä»¥ä½¿æ‚¨çš„ä»£ç æ›´å¯é¢„æµ‹ã€æ›´æ˜“äºç®¡ç†ä¸”æ›´å®‰å…¨ã€‚

ä½¿ç”¨å¼ºç±»å‹æ£€æŸ¥çš„ä¸»è¦æ–¹æ³•ä¹‹ä¸€æ˜¯ä½¿ç”¨ Mojo çš„`struct`ç±»å‹ã€‚Mojo ä¸­çš„å®šä¹‰`struct`å®šä¹‰äº†ä¸€ä¸ªç¼–è¯‘æ—¶ç»‘å®šçš„åç§°ï¼Œå¹¶ä¸”å¯¹æ‰€å®šä¹‰çš„å€¼æ¥è¯´ï¼Œåœ¨ç±»å‹ä¸Šä¸‹æ–‡ä¸­å¯¹è¯¥åç§°çš„å¼•ç”¨è¢«è§†ä¸ºå¼ºè§„èŒƒã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹ä»£ç ï¼Œä½¿ç”¨ä¸Šè¿°ç»“æ„`MyPair`ï¼š

```
def pair_test() -> Bool:
    let p = MyPair(1, 2)
    # Uncomment to see an error:
    # return p < 4 # gives a compile time error
    return True
```

å¦‚æœå–æ¶ˆæ³¨é‡Šç¬¬ä¸€ä¸ª return è¯­å¥å¹¶è¿è¡Œå®ƒï¼Œæ‚¨å°†æ”¶åˆ°ä¸€ä¸ªç¼–è¯‘æ—¶é”™è¯¯ï¼Œå‘Šè¯‰æ‚¨æ— æ³•`4`è½¬æ¢ä¸º`MyPair`ï¼Œè¿™æ˜¯`__lt__()`å³ä¾§æ‰€éœ€è¦çš„ï¼ˆåœ¨`MyPair`å®šä¹‰ä¸­ï¼‰ã€‚

åœ¨ä½¿ç”¨ç³»ç»Ÿç¼–ç¨‹è¯­è¨€æ—¶ï¼Œè¿™ç§åšæ³•å¾ˆç†Ÿæ‚‰ï¼Œä½† Python å¹¶ä¸æ˜¯è¿™æ ·å·¥ä½œçš„ã€‚Python å¯¹äº[MyPy](https://mypy.readthedocs.io/)ç±»å‹æ³¨é‡Šå…·æœ‰è¯­æ³•ç›¸åŒçš„åŠŸèƒ½ï¼Œä½†å®ƒä»¬ä¸æ˜¯ç”±ç¼–è¯‘å™¨å¼ºåˆ¶æ‰§è¡Œçš„ï¼šç›¸åï¼Œå®ƒä»¬æ˜¯é€šçŸ¥é™æ€åˆ†æçš„æç¤ºã€‚é€šè¿‡å°†ç±»å‹ç»‘å®šåˆ°ç‰¹å®šå£°æ˜ï¼ŒMojo å¯ä»¥å¤„ç†ç»å…¸ç±»å‹æ³¨é‡Šæç¤ºå’Œå¼ºç±»å‹è§„èŒƒï¼Œè€Œä¸ä¼šç ´åå…¼å®¹æ€§ã€‚

ç±»å‹æ£€æŸ¥å¹¶ä¸æ˜¯å¼ºç±»å‹çš„å”¯ä¸€ç”¨ä¾‹ã€‚ç”±äºæˆ‘ä»¬çŸ¥é“ç±»å‹æ˜¯å‡†ç¡®çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æ ¹æ®è¿™äº›ç±»å‹ä¼˜åŒ–ä»£ç ï¼Œåœ¨å¯„å­˜å™¨ä¸­ä¼ é€’å€¼ï¼Œå¹¶åœ¨å‚æ•°ä¼ é€’å’Œå…¶ä»–ä½çº§ç»†èŠ‚æ–¹é¢ä¿æŒä¸ C ä¸€æ ·é«˜æ•ˆã€‚è¿™æ˜¯ Mojo ä¸ºç³»ç»Ÿç¨‹åºå‘˜æä¾›å®‰å…¨æ€§å’Œå¯é¢„æµ‹æ€§ä¿è¯çš„åŸºç¡€ã€‚

### [é‡è½½çš„å‡½æ•°å’Œæ–¹æ³•](#overloaded-functions-and-methods)

ä¸ Python ä¸€æ ·ï¼Œæ‚¨å¯ä»¥åœ¨ Mojo ä¸­å®šä¹‰å‡½æ•°è€Œæ— éœ€æŒ‡å®šå‚æ•°æ•°æ®ç±»å‹ï¼ŒMojo å°†åŠ¨æ€å¤„ç†å®ƒä»¬ã€‚å½“æ‚¨æƒ³è¦å¯Œæœ‰è¡¨ç°åŠ›çš„ API ï¼Œæ¥å—ä»»æ„è¾“å…¥å¹¶è®©åŠ¨æ€è°ƒåº¦å†³å®šå¦‚ä½•å¤„ç†æ•°æ®æ—¶ï¼Œè¿™å¾ˆå¥½ã€‚ç„¶è€Œï¼Œå½“æ‚¨æƒ³è¦ç¡®ä¿ç±»å‹å®‰å…¨æ—¶ï¼Œå¦‚ä¸Šæ‰€è¿°ï¼ŒMojo è¿˜æä¾›å¯¹é‡è½½å‡½æ•°å’Œæ–¹æ³•çš„å…¨é¢æ”¯æŒã€‚

è¿™å…è®¸æ‚¨å®šä¹‰å¤šä¸ªå…·æœ‰ç›¸åŒåç§°ä½†å…·æœ‰ä¸åŒå‚æ•°çš„å‡½æ•°ã€‚è¿™æ˜¯è®¸å¤šè¯­è¨€ï¼ˆä¾‹å¦‚ C++ã€Java å’Œ Swiftï¼‰ä¸­çš„å¸¸è§åŠŸèƒ½ã€‚

è§£æå‡½æ•°è°ƒç”¨æ—¶ï¼ŒMojo ä¼šå°è¯•æ¯ä¸ªå€™é€‰å‡½æ•°å¹¶ä½¿ç”¨æœ‰æ•ˆçš„ä¸€ä¸ªï¼ˆå¦‚æœåªæœ‰ä¸€ä¸ªæœ‰æ•ˆï¼‰ï¼Œæˆ–è€…é€‰æ‹©æœ€æ¥è¿‘çš„åŒ¹é…ï¼ˆå¦‚æœå¯ä»¥ç¡®å®šä¸€ä¸ªæ¥è¿‘çš„åŒ¹é…ï¼‰ï¼Œæˆ–è€…æŠ¥å‘Šè°ƒç”¨ä¸æ˜ç¡®å¦‚æœä¸çŸ¥é“è¯¥é€‰å“ªä¸€ä¸ªã€‚åœ¨åä¸€ç§æƒ…å†µä¸‹ï¼Œæ‚¨å¯ä»¥é€šè¿‡åœ¨è°ƒç”¨ç«™ç‚¹ä¸Šæ·»åŠ æ˜¾å¼è½¬æ¢æ¥è§£å†³æ­§ä¹‰ã€‚

è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```
struct Complex:
    var re: Float32
    var im: Float32

    fn __init__(inout self, x: Float32):
        """Construct a complex number given a real number."""
        self.re = x
        self.im = 0.0

    fn __init__(inout self, r: Float32, i: Float32):
        """Construct a complex number given its real and imaginary components."""
        self.re = r
        self.im = i
```

æ‚¨å¯ä»¥é‡è½½ç»“æ„å’Œç±»ä¸­çš„æ–¹æ³•ä»¥åŠé‡è½½æ¨¡å—çº§å‡½æ•°ã€‚

Mojo ä¸æ”¯æŒä»…åœ¨ç»“æœç±»å‹ä¸Šé‡è½½ï¼Œå¹¶ä¸”ä¸ä½¿ç”¨ç»“æœç±»å‹æˆ–ä¸Šä¸‹æ–‡ç±»å‹ä¿¡æ¯è¿›è¡Œç±»å‹æ¨æ–­ï¼Œä»è€Œä½¿äº‹æƒ…ä¿æŒç®€å•ã€å¿«é€Ÿå’Œå¯é¢„æµ‹ã€‚Mojo æ°¸è¿œä¸ä¼šäº§ç”Ÿâ€œè¡¨è¾¾å¼å¤ªå¤æ‚â€é”™è¯¯ï¼Œå› ä¸ºå®ƒçš„ç±»å‹æ£€æŸ¥å™¨æ˜¯ç®€å•ä¸”å¿«é€Ÿçš„ã€‚

åŒæ ·ï¼Œå¦‚æœæ‚¨çš„å‚æ•°åç§°ä¸å¸¦ç±»å‹å®šä¹‰ï¼Œåˆ™è¯¥å‡½æ•°çš„è¡Œä¸ºå°±åƒå…·æœ‰åŠ¨æ€ç±»å‹çš„ Python ä¸€æ ·ã€‚ä¸€æ—¦å®šä¹‰äº†å•ä¸ªå‚æ•°ç±»å‹ï¼ŒMojo å°†æŸ¥æ‰¾é‡è½½å‡½æ•°å¹¶è§£æå‡½æ•°è°ƒç”¨ï¼Œå¦‚ä¸Šæ‰€è¿°ã€‚

è™½ç„¶æˆ‘ä»¬è¿˜æ²¡æœ‰è®¨è®ºå‚æ•°ï¼ˆå®ƒä»¬ä¸å‡½æ•°å‚æ•°ä¸åŒï¼‰ï¼Œä½†æ‚¨ä¹Ÿå¯ä»¥[åŸºäºå‚æ•°é‡è½½å‡½æ•°å’Œæ–¹æ³•](https://docs.modular.com/mojo/programming-manual.html#overloading-on-parameters)ã€‚

### [`fn`å®šä¹‰](#fn-definitions)

ä¸Šè¿°æ‰©å±•æ˜¯æä¾›ä½çº§ç¼–ç¨‹å’ŒæŠ½è±¡åŠŸèƒ½çš„åŸºçŸ³ï¼Œä½†è®¸å¤šç³»ç»Ÿç¨‹åºå‘˜å–œæ¬¢æ›´å¤šå¯æ§æ€§å’Œå¯é¢„æµ‹æ€§ï¼Œç›¸æ¯”ä¸ Mojo ä¸­`def`æ‰€æä¾›çš„ã€‚å›é¡¾ä¸€ä¸‹ï¼Œ`def`å®ƒçš„å®šä¹‰å¿…é¡»éå¸¸åŠ¨æ€ã€çµæ´»å¹¶ä¸”é€šå¸¸ä¸ Python å…¼å®¹ï¼šå‚æ•°æ˜¯å¯å˜çš„ï¼Œå±€éƒ¨å˜é‡åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶éšå¼å£°æ˜ï¼Œå¹¶ä¸”ä¸å¼ºåˆ¶æ‰§è¡Œä½œç”¨åŸŸã€‚è¿™å¯¹äºé«˜çº§ç¼–ç¨‹å’Œè„šæœ¬ç¼–å†™æ¥è¯´éå¸¸æœ‰ç”¨ï¼Œä½†å¯¹äºç³»ç»Ÿç¼–ç¨‹æ¥è¯´å¹¶ä¸æ€»æ˜¯é‚£ä¹ˆå¥½ã€‚ä¸ºäº†è¡¥å……è¿™ä¸€ç‚¹ï¼ŒMojo æä¾›äº†ä¸€ä¸ª`fn`å£°æ˜ï¼Œç±»ä¼¼äº`def`çš„ä¸¥æ ¼æ¨¡å¼.

> æ›¿ä»£æ–¹æ¡ˆï¼šæˆ‘ä»¬å¯ä»¥æ·»åŠ ä¿®é¥°ç¬¦æˆ–è£…é¥°å™¨ç±»ä¼¼äº`@strict def`ï¼Œè€Œä¸æ˜¯ä½¿ç”¨åƒ`fn`è¿™æ ·çš„æ–°å…³é”®å­—ã€‚ç„¶è€Œï¼Œæ— è®ºå¦‚ä½•æˆ‘ä»¬éƒ½éœ€è¦é‡‡ç”¨æ–°çš„å…³é”®è¯ï¼Œè€Œä¸”è¿™æ ·åšæœ‰ä¸€å®šæˆæœ¬ã€‚æ­¤å¤–ï¼Œåœ¨ç³»ç»Ÿç¼–ç¨‹é¢†åŸŸçš„å®è·µä¸­ï¼Œ`fn`å®ƒä¸€ç›´è¢«ä½¿ç”¨ï¼Œå› æ­¤ä½¿å…¶æˆä¸ºç¬¬ä¸€é€‰æ‹©ã€‚

å°±è°ƒç”¨è€…è€Œè¨€ï¼Œ`fn`å’Œ`def`æ˜¯å¯ä»¥äº’æ¢çš„ï¼šæ²¡æœ‰ä»€ä¹ˆæ˜¯ `def`å¯ä»¥æä¾›è€Œ `fn`ä¸èƒ½æä¾›çš„ï¼ˆåä¹‹äº¦ç„¶ï¼‰ã€‚ä¸åŒä¹‹å¤„åœ¨äºï¼Œåœ¨`fn`_å†…éƒ¨_å—åˆ°æ›´å¤šé™åˆ¶å’Œæ§åˆ¶ï¼ˆæˆ–è€…ï¼šè¿‚è…å’Œä¸¥æ ¼ï¼‰ã€‚å…·ä½“æ¥è¯´ï¼Œ`def`ä¸å‡½æ•°ç›¸æ¯”ï¼Œ`fn`æœ‰è®¸å¤šé™åˆ¶ï¼š

1. å‚æ•°å€¼é»˜è®¤åœ¨å‡½æ•°ä½“å†…æ˜¯ä¸å¯å˜çš„ï¼ˆåƒ`let`ä¸€æ ·ï¼‰ï¼Œè€Œä¸æ˜¯å¯å˜çš„ï¼ˆåƒ`var`ä¸€æ ·ï¼‰ã€‚è¿™ä¼šæ•è·æ„å¤–çªå˜ï¼Œå¹¶å…è®¸ä½¿ç”¨ä¸å¯å¤åˆ¶çš„ç±»å‹ä½œä¸ºå‚æ•°ã€‚
2. å‚æ•°å€¼éœ€è¦ç±»å‹è§„èŒƒï¼ˆ`self`æ–¹æ³•ä¸­é™¤å¤–ï¼‰ï¼Œä»¥æ•è·ç±»å‹è§„èŒƒçš„æ„å¤–é—æ¼ã€‚åŒæ ·ï¼Œç¼ºå°‘è¿”å›ç±»å‹è¯´æ˜ç¬¦ä¼šè¢«è§£é‡Šä¸ºè¿”å›`None`è€Œä¸æ˜¯æœªçŸ¥çš„è¿”å›ç±»å‹ã€‚è¯·æ³¨æ„ï¼Œä¸¤è€…éƒ½å¯ä»¥æ˜¾å¼å£°æ˜ä¸ºè¿”å›`object`ï¼Œè¿™å…è®¸äººä»¬æ ¹æ®éœ€è¦é€‰æ‹©åŠ å…¥`def`ã€‚
3. å±€éƒ¨å˜é‡çš„éšå¼å£°æ˜è¢«ç¦ç”¨ï¼Œå› æ­¤å¿…é¡»å£°æ˜æ‰€æœ‰å±€éƒ¨å˜é‡ã€‚è¿™å¯ä»¥æ•è·åç§°æ‹¼å†™é”™è¯¯å¹¶ä¸`let`å’Œ`var`æä¾›çš„èŒƒå›´ç›¸å»åˆã€‚
4. ä¸¤è€…éƒ½æ”¯æŒå¼•å‘å¼‚å¸¸ï¼Œä½†`fn`å¿…é¡»ä½¿ç”¨`raises`å…³é”®å­—æ˜¾å¼å£°æ˜ã€‚

ä¸åŒå›¢é˜Ÿçš„ç¼–ç¨‹æ¨¡å¼ä¼šæœ‰å¾ˆå¤§å·®å¼‚ï¼Œè¿™ç§ä¸¥æ ¼ç¨‹åº¦å¹¶ä¸é€‚åˆæ‰€æœ‰äººã€‚æˆ‘ä»¬å¸Œæœ›ä¹ æƒ¯ C++ å¹¶å·²åœ¨ Python ä¸­ä½¿ç”¨ MyPy é£æ ¼ç±»å‹æ³¨é‡Šçš„äººä»¬æ›´å–œæ¬¢ä½¿ç”¨`fn`ï¼Œä½†æ›´é«˜çº§åˆ«çš„ç¨‹åºå‘˜å’Œ ML ç ”ç©¶äººå‘˜å°†ç»§ç»­ä½¿ç”¨`def`. Mojo å…è®¸æ‚¨è‡ªç”±åœ°æ··åˆ`def`å’Œ`fn`å£°æ˜ï¼Œä¾‹å¦‚ç”¨ä¸€ç§æ–¹æ³•å®ç°æŸäº›æ–¹æ³•ï¼Œç”¨å¦ä¸€ç§æ–¹æ³•å®ç°å¦ä¸€äº›æ–¹æ³•ï¼Œå¹¶å…è®¸æ¯ä¸ªå›¢é˜Ÿæˆ–ç¨‹åºå‘˜å†³å®šä»€ä¹ˆæœ€é€‚åˆä»–ä»¬çš„ç”¨ä¾‹ã€‚

[æœ‰å…³ Mojo å‡½æ•°ä¸­å‚æ•°è¡Œä¸ºçš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ä¸‹é¢æœ‰å…³å‚æ•°ä¼ é€’æ§åˆ¶å’Œå†…å­˜æ‰€æœ‰æƒ](https://docs.modular.com/mojo/programming-manual.html#argument-passing-control-and-memory-ownership)çš„éƒ¨åˆ†ã€‚

### [`copyinit`ã€`moveinit`å’Œ`takeinit`ç‰¹æ®Šæ–¹æ³•](#the-copyinit-moveinit-and-takeinit-special-methods)

Mojo æ”¯æŒå®Œæ•´çš„â€œå€¼è¯­ä¹‰â€ï¼Œå¦‚ C++ å’Œ Swift ç­‰è¯­è¨€ä¸­æ‰€ç¤ºï¼Œå¹¶ä¸”å®ƒä½¿å¾—å®šä¹‰ç®€å•çš„å­—æ®µèšåˆå˜å¾—éå¸¸å®¹æ˜“é€šè¿‡[`@value`è£…é¥°å™¨](https://docs.modular.com/mojo/programming-manual.html#value-decorator)ã€‚

å¯¹äºé«˜çº§ç”¨ä¾‹ï¼ŒMojo å…è®¸æ‚¨å®šä¹‰è‡ªå®šä¹‰æ„é€ å‡½æ•°ï¼ˆä½¿ç”¨ Python ç°æœ‰çš„`__init__`ç‰¹æ®Šæ–¹æ³•ï¼‰ ã€è‡ªå®šä¹‰ææ„å‡½æ•°ï¼ˆä½¿ç”¨ç°æœ‰çš„`__del__`ç‰¹æ®Šæ–¹æ³•ï¼‰ä»¥åŠè‡ªå®šä¹‰å¤åˆ¶å’Œç§»åŠ¨æ„é€ å‡½æ•°ï¼ˆä½¿ç”¨`__copyinit__`ã€`__moveinit__`å’Œ`__takeinit__`ç‰¹æ®Šæ–¹æ³•ï¼‰ã€‚

è¿™äº›ä½çº§å®šåˆ¶æŒ‚é’©å‡½æ•°åœ¨è¿›è¡Œä½çº§ç³»ç»Ÿç¼–ç¨‹ï¼ˆä¾‹å¦‚æ‰‹åŠ¨å†…å­˜ç®¡ç†ï¼‰æ—¶éå¸¸æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸€ä¸ªåŠ¨æ€å­—ç¬¦ä¸²ç±»å‹ï¼Œå®ƒéœ€è¦åœ¨æ„é€ æ—¶ä¸ºå­—ç¬¦ä¸²æ•°æ®åˆ†é…å†…å­˜ï¼Œå¹¶åœ¨é”€æ¯å€¼æ—¶é”€æ¯å®ƒï¼š

```
from memory.unsafe import Pointer

struct HeapArray:
    var data: Pointer[Int]
    var size: Int

    fn __init__(inout self, size: Int, val: Int):
        self.size = size
        self.data = Pointer[Int].alloc(self.size)
        for i in range(self.size):
            self.data.store(i, val)
     
    fn __del__(owned self):
        self.data.free()

    fn dump(self):
        print_no_newline("[")
        for i in range(self.size):
            if i > 0:
                print_no_newline(", ")
            print_no_newline(self.data.load(i))
        print("]")
```

è¯¥æ•°ç»„ç±»å‹æ˜¯ä½¿ç”¨ä½çº§å‡½æ•°å®ç°çš„ï¼Œä»¥å±•ç¤ºå…¶å·¥ä½œåŸç†çš„ç®€å•ç¤ºä¾‹ã€‚ä½†æ˜¯ï¼Œå¦‚æœæ‚¨å°è¯•ä½¿ç”¨`=è¿ç®—ç¬¦å¤åˆ¶`HeapArray`çš„å®ä¾‹`ï¼Œæ‚¨å¯èƒ½ä¼šæ„Ÿåˆ°æƒŠè®¶ï¼š

```
var a = HeapArray(3, 1)
a.dump()   # Should print [1, 1, 1]
# Uncomment to see an error:
# var b = a  # ERROR: Vector doesn't implement __copyinit__

var b = HeapArray(4, 2)
b.dump()   # Should print [2, 2, 2, 2]
a.dump()   # Should print [1, 1, 1]
```

```
[1, 1, 1]
[2, 2, 2, 2]
[1, 1, 1]
```

å¦‚æœæ‚¨å–æ¶ˆæ³¨é‡Šå°†`a`å¤åˆ¶åˆ°`b`çš„è¡Œï¼Œæ‚¨å°†çœ‹åˆ° Mojo ä¸å…è®¸æ‚¨å¤åˆ¶çš„æ•°ç»„ï¼š`HeapArray`åŒ…å«ä¸€ä¸ª`Pointer`å®ä¾‹ï¼ˆç›¸å½“äºä½çº§ C æŒ‡é’ˆï¼‰ï¼Œè€Œ Mojo ä¸å…è®¸çŸ¥é“å®ƒæŒ‡å‘ä»€ä¹ˆç±»å‹çš„æ•°æ®æˆ–å¦‚ä½•å¤åˆ¶å®ƒã€‚æ›´å¸¸è§çš„è¯´ï¼ŒæŸäº›ç±»å‹ï¼ˆå¦‚åŸå­åºæ•°ï¼‰æ— æ³•å¤åˆ¶æˆ–ç§»åŠ¨ï¼Œå› ä¸ºå®ƒä»¬çš„åœ°å€æä¾›äº†ä¸€ä¸ª**èº«ä»½**ï¼Œå°±åƒç±»å®ä¾‹ä¸€æ ·ã€‚

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç¡®å®å¸Œæœ›æˆ‘ä»¬çš„æ•°ç»„æ˜¯å¯å¤åˆ¶çš„ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¿…é¡»å®ç°`__copyinit__`ç‰¹æ®Šçš„æ–¹æ³•ï¼Œé€šå¸¸æ˜¯è¿™æ ·å®ç°çš„ï¼š

```
struct HeapArray:
    var data: Pointer[Int]
    var size: Int

    fn __init__(inout self, size: Int, val: Int):
        self.size = size
        self.data = Pointer[Int].alloc(self.size)
        for i in range(self.size):
            self.data.store(i, val)

    fn __copyinit__(inout self, other: Self):
        self.size = other.size
        self.data = Pointer[Int].alloc(self.size)
        for i in range(self.size):
            self.data.store(i, other.data.load(i))
            
    fn __del__(owned self):
        self.data.free()

    fn dump(self):
        print_no_newline("[")
        for i in range(self.size):
            if i > 0:
                print_no_newline(", ")
            print_no_newline(self.data.load(i))
        print("]")
```

é€šè¿‡æ­¤å®ç°ï¼Œæˆ‘ä»¬ä¸Šé¢çš„ä»£ç å¯ä»¥æ­£å¸¸å·¥ä½œï¼Œå¹¶ä¸”`b = a`å‰¯æœ¬ä¼šç”Ÿæˆé€»è¾‘ä¸Šä¸åŒçš„æ•°ç»„å®ä¾‹ï¼Œå¹¶å…·æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸå’Œæ•°æ®ï¼š

```
var a = HeapArray(3, 1)
a.dump()   # Should print [1, 1, 1]
# This is no longer an error:
var b = a

b.dump()   # Should print [1, 1, 1]
a.dump()   # Should print [1, 1, 1]
```

```
[1, 1, 1]
[1, 1, 1]
[1, 1, 1]
```

Mojo è¿˜æ”¯æŒ`__moveinit__`æ–¹æ³•å…è®¸ Rust é£æ ¼çš„ç§»åŠ¨ï¼ˆå½“æºç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶å°†å€¼ä»ä¸€ä¸ªåœ°æ–¹ä¼ è¾“åˆ°å¦ä¸€ä¸ªåœ°æ–¹ï¼‰å’Œ`__takeinit__`C++ é£æ ¼çš„ç§»åŠ¨æ–¹æ³•ï¼ˆå…¶ä¸­å€¼çš„å†…å®¹ä»æºä¸­ä¼ è¾“å‡ºæ¥ï¼Œä½†å…¶ææ„å‡½æ•°ä»åœ¨è¿è¡Œï¼‰ï¼Œå¹¶å…è®¸è‡ªå®šä¹‰ç§»åŠ¨é€»è¾‘ã€‚æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…ä¸‹é¢çš„[â€œä»·å€¼ç”Ÿå‘½å‘¨æœŸâ€](https://docs.modular.com/mojo/programming-manual.html#value-lifecycle-birth-life-and-death-of-a-value)éƒ¨åˆ†ã€‚

Mojo æä¾›å¯¹å€¼çš„ç”Ÿå‘½å‘¨æœŸçš„å®Œå…¨æ§åˆ¶ï¼ŒåŒ…æ‹¬ä½¿ç±»å‹å¯å¤åˆ¶ã€ä»…ç§»åŠ¨å’Œä¸å¯ç§»åŠ¨çš„èƒ½åŠ›ã€‚è¿™æ¯” Swift å’Œ Rust ç­‰è¯­è¨€æä¾›çš„æ§åˆ¶èƒ½åŠ›æ›´å¼ºï¼Œåè€…è¦æ±‚å€¼è‡³å°‘æ˜¯å¯ç§»åŠ¨çš„ã€‚å¦‚æœæ‚¨å¥½å¥‡å¦‚ä½•åœ¨ä¸åˆ›å»ºå‰¯æœ¬çš„æƒ…å†µä¸‹å°†`existing`ä¼ é€’åˆ°`__copyinit__`æ–¹æ³•ä¸­ï¼Œè¯·æŸ¥çœ‹ä¸‹é¢[æœ‰å…³å€Ÿç”¨å‚æ•°çš„](https://docs.modular.com/mojo/programming-manual.html#immutable-arguments-borrowed)éƒ¨åˆ†ã€‚

## [å‚æ•°ä¼ é€’æ§åˆ¶å’Œå†…å­˜æ‰€æœ‰æƒ](#argument-passing-control-and-memory-ownership)

åœ¨ Python å’Œ Mojo ä¸­ï¼Œå¤§éƒ¨åˆ†è¯­æ³•éƒ½å›´ç»•å‡½æ•°è°ƒç”¨ï¼šè®¸å¤šå†…ç½®è¡Œä¸ºæ˜¯åœ¨æ ‡å‡†åº“ä¸­ä½¿ç”¨â€œdunderâ€æ–¹æ³•å®ç°çš„ã€‚åœ¨è¿™äº›ç¥å¥‡çš„å‡½æ•°å†…éƒ¨ï¼Œè®¸å¤šå†…å­˜æ‰€æœ‰æƒæ˜¯é€šè¿‡å‚æ•°ä¼ é€’æ¥ç¡®å®šçš„ã€‚

è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹æœ‰å…³ Python å’Œ Mojo å¦‚ä½•ä¼ é€’å‚æ•°çš„ä¸€äº›ç»†èŠ‚ï¼š

* æ‰€æœ‰ä¼ é€’åˆ°_Python_ `def`å‡½æ•°çš„å€¼éƒ½ä½¿ç”¨å¼•ç”¨è¯­ä¹‰ã€‚è¿™æ„å‘³ç€è¯¥å‡½æ•°å¯ä»¥ä¿®æ”¹ä¼ é€’ç»™å®ƒçš„å¯å˜å¯¹è±¡ï¼Œå¹¶ä¸”è¿™äº›æ›´æ”¹åœ¨å‡½æ•°å¤–éƒ¨å¯è§ã€‚ç„¶è€Œï¼Œè¿™ç§è¡Œä¸ºæœ‰æ—¶ä¼šè®©å¤–è¡Œäººæ„Ÿåˆ°æƒŠè®¶ï¼Œå› ä¸ºæ‚¨å¯ä»¥æ›´æ”¹å‚æ•°æŒ‡å‘çš„å¯¹è±¡ï¼Œå¹¶ä¸”è¯¥æ›´æ”¹åœ¨å‡½æ•°å¤–éƒ¨ä¸å¯è§ã€‚
* é»˜è®¤æƒ…å†µä¸‹ï¼Œä¼ é€’åˆ°_Mojo_ `def`å‡½æ•°çš„æ‰€æœ‰å€¼éƒ½ä½¿ç”¨å€¼è¯­ä¹‰ã€‚ä¸ Python ç›¸æ¯”ï¼Œè¿™æ˜¯ä¸€ä¸ªé‡è¦çš„åŒºåˆ«ï¼šMojo`def`å‡½æ•°æ¥æ”¶æ‰€æœ‰å‚æ•°çš„å‰¯æœ¬ï¼Œå®ƒå¯ä»¥ä¿®æ”¹å‡½æ•°å†…éƒ¨çš„å‚æ•°ï¼Œä½†æ›´æ”¹åœ¨å‡½æ•°å¤–éƒ¨**ä¸å¯è§ã€‚**
* é»˜è®¤æƒ…å†µä¸‹ï¼Œä¼ é€’åˆ° Mojo[`fn`å‡½æ•°](https://docs.modular.com/mojo/programming-manual.html#fn-definitions)çš„æ‰€æœ‰å€¼éƒ½æ˜¯ä¸å¯å˜å¼•ç”¨ã€‚è¿™æ„å‘³ç€è¯¥å‡½æ•°å¯ä»¥è¯»å–åŸå§‹å¯¹è±¡ï¼ˆå®ƒä¸æ˜¯_å‰¯æœ¬_ï¼‰ï¼Œä½†å®ƒæ ¹æœ¬æ— æ³•ä¿®æ”¹è¯¥å¯¹è±¡ã€‚

è¿™ç§åœ¨ Mojo ä¸­ä¼ é€’ä¸å¯å˜å‚æ•°çš„çº¦å®š`fn`ç§°ä¸ºâ€œå€Ÿç”¨â€ã€‚åœ¨ä»¥ä¸‹éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†è§£é‡Šå¦‚ä½•æ›´æ”¹ Mojo ä¸­`def`å’Œ`fn`å‡½æ•°çš„å‚æ•°ä¼ é€’è¡Œä¸ºã€‚

### [ä¸ºä»€ä¹ˆè®ºè¯çº¦å®šå¾ˆé‡è¦](#why-argument-conventions-are-important)

åœ¨ Python ä¸­ï¼Œæ‰€æœ‰åŸºæœ¬å€¼éƒ½æ˜¯å¯¹å¯¹è±¡çš„å¼•ç”¨ï¼Œå¦‚ä¸Šæ‰€è¿°ï¼ŒPython å‡½æ•°å¯ä»¥ä¿®æ”¹åŸå§‹å¯¹è±¡ã€‚å› æ­¤ï¼ŒPython å¼€å‘äººå‘˜ä¹ æƒ¯äºå°†ä¸€åˆ‡éƒ½è§†ä¸ºå‚è€ƒè¯­ä¹‰ã€‚ç„¶è€Œï¼Œåœ¨ CPython æˆ–æœºå™¨çº§åˆ«ï¼Œæ‚¨å¯ä»¥çœ‹åˆ°å¼•ç”¨æœ¬èº«å®é™…ä¸Šæ˜¯*é€šè¿‡å¤åˆ¶*ä¼ é€’çš„ï¼šPython å¤åˆ¶æŒ‡é’ˆå¹¶è°ƒæ•´å¼•ç”¨è®¡æ•°ã€‚

è¿™ç§ Python æ–¹æ³•ä¸ºå¤§å¤šæ•°äººæä¾›äº†ä¸€ä¸ªèˆ’é€‚çš„ç¼–ç¨‹æ¨¡å‹ï¼Œä½†å®ƒè¦æ±‚æ‰€æœ‰å€¼éƒ½è¿›è¡Œå †åˆ†é…ï¼ˆç”±äºå¼•ç”¨å…±äº«ï¼Œç»“æœæœ‰æ—¶ä¼šä»¤äººæƒŠè®¶ï¼‰ã€‚Mojo ç±»ï¼ˆå°†æ¥ä¼šå®ç°ï¼‰å¯¹å¤§å¤šæ•°å¯¹è±¡éµå¾ªç›¸åŒçš„å¼•ç”¨è¯­ä¹‰æ–¹æ³•ï¼Œä½†è¿™å¯¹äºç³»ç»Ÿç¼–ç¨‹ä¸Šä¸‹æ–‡ä¸­çš„æ•´æ•°ç­‰ç®€å•ç±»å‹æ¥è¯´å¹¶ä¸å®ç”¨ã€‚åœ¨è¿™äº›åœºæ™¯ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›è¿™äº›å€¼å­˜åœ¨äºå †æ ˆä¸­ï¼Œç”šè‡³å­˜åœ¨äºç¡¬ä»¶å¯„å­˜å™¨ä¸­ã€‚å› æ­¤ï¼ŒMojo ç»“æ„æ€»æ˜¯å†…è”åˆ°å…¶å®¹å™¨ä¸­ï¼Œæ— è®ºæ˜¯ä½œä¸ºå¦ä¸€ç§ç±»å‹çš„å­—æ®µè¿˜æ˜¯åŒ…å«å‡½æ•°çš„å †æ ˆå¸§ã€‚

è¿™æå‡ºäº†ä¸€äº›æœ‰è¶£çš„é—®é¢˜ï¼šå¦‚ä½•å®ç°éœ€è¦æ”¹å˜`self`ç»“æ„ç±»å‹çš„æ–¹æ³•ï¼Œä¾‹å¦‚`__iadd__`ï¼Ÿ`let`æ˜¯å¦‚ä½•å·¥ä½œçš„ä»¥åŠå¦‚ä½•é˜²æ­¢çªå˜ï¼Ÿå¦‚ä½•æ§åˆ¶è¿™äº›å€¼çš„ç”Ÿå‘½å‘¨æœŸä»¥ä½¿ Mojo æˆä¸ºå†…å­˜å®‰å…¨çš„è¯­è¨€ï¼Ÿ

ç­”æ¡ˆæ˜¯ï¼ŒMojo ç¼–è¯‘å™¨ä½¿ç”¨æ•°æ®æµåˆ†æå’Œç±»å‹æ³¨é‡Šæ¥æä¾›å¯¹å€¼å‰¯æœ¬ã€å¼•ç”¨åˆ«åå’Œçªå˜æ§åˆ¶çš„å®Œå…¨æ§åˆ¶ã€‚è¿™äº›åŠŸèƒ½åœ¨å¾ˆå¤šæ–¹é¢ä¸ Rust è¯­è¨€ä¸­çš„åŠŸèƒ½ç›¸ä¼¼ï¼Œä½†å®ƒä»¬çš„å·¥ä½œæ–¹å¼æœ‰æ‰€ä¸åŒï¼Œä»¥ä¾¿ä½¿ Mojo æ›´å®¹æ˜“å­¦ä¹ ï¼Œå¹¶ä¸”å®ƒä»¬å¯ä»¥æ›´å¥½åœ°é›†æˆåˆ° Python ç”Ÿæ€ç³»ç»Ÿä¸­ï¼Œè€Œä¸éœ€è¦å¤§é‡çš„æ³¨é‡Šè´Ÿæ‹…ã€‚

åœ¨ä»¥ä¸‹éƒ¨åˆ†ä¸­ï¼Œæ‚¨å°†äº†è§£å¦‚ä½•æ§åˆ¶ä¼ é€’åˆ° Mojo`fn`å‡½æ•°çš„å¯¹è±¡çš„å†…å­˜æ‰€æœ‰æƒã€‚

### [ä¸å¯å˜å‚æ•°( `borrowed` )](#immutable-arguments-borrowed)

å€Ÿç”¨å¯¹è±¡æ˜¯å¯¹å‡½æ•°æ¥æ”¶çš„å¯¹è±¡çš„**ä¸å¯å˜å¼•ç”¨**ï¼Œè€Œä¸æ˜¯æ¥æ”¶è¯¥å¯¹è±¡çš„å‰¯æœ¬ã€‚å› æ­¤ï¼Œè¢«è°ƒç”¨å‡½æ•°å…·æœ‰å¯¹è¯¥å¯¹è±¡çš„å®Œå…¨è¯»å–å’Œæ‰§è¡Œè®¿é—®æƒé™ï¼Œä½†æ— æ³•ä¿®æ”¹å®ƒï¼ˆè°ƒç”¨è€…ä»ç„¶æ‹¥æœ‰è¯¥å¯¹è±¡çš„ç‹¬å â€œæ‰€æœ‰æƒâ€ï¼‰ã€‚

ä¾‹å¦‚ï¼Œè€ƒè™‘è¿™ä¸ªç»“æ„ï¼Œæˆ‘ä»¬åœ¨ä¼ é€’å®ƒçš„å®ä¾‹æ—¶ä¸æƒ³å¤åˆ¶å®ƒï¼š

```
# Don't worry about this code yet. It's just needed for the function below.
# It's a type so expensive to copy around so it does not have a
# __copyinit__ method.
struct SomethingBig:
    var id_number: Int
    var huge: HeapArray
    fn __init__(inout self, id: Int):
        self.huge = HeapArray(1000, 0)
        self.id_number = id

    # self is passed by-reference for mutation as described above.
    fn set_id(inout self, number: Int):
        self.id_number = number

    # Arguments like self are passed as borrowed by default.
    fn print_id(self):  # Same as: fn print_id(borrowed self):
        print(self.id_number)
```

å½“å°†`SomethingBig`çš„å®ä¾‹ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œæœ‰å¿…è¦ä¼ é€’å¼•ç”¨ï¼Œå› ä¸º`SomethingBig`æ— æ³•å¤åˆ¶ï¼ˆå®ƒæ²¡æœ‰`__copyinit__`æ–¹æ³•ï¼‰ã€‚å¹¶ä¸”ï¼Œå¦‚ä¸Šæ‰€è¿°ï¼Œ`fn`é»˜è®¤æƒ…å†µä¸‹å‚æ•°æ˜¯ä¸å¯å˜å¼•ç”¨ï¼Œä½†æ‚¨å¯ä»¥ä½¿ç”¨`borrowed`å…³é”®å­—æ˜¾å¼å®šä¹‰å®ƒï¼Œå¦‚æ­¤å¤„å‡½æ•°æ‰€ç¤º`use_something_big()`ï¼š

```
fn use_something_big(borrowed a: SomethingBig, b: SomethingBig):
    """'a' and 'b' are both immutable, because 'borrowed' is the default."""
    a.print_id()
    b.print_id()

let a = SomethingBig(10)
let b = SomethingBig(20)
use_something_big(a, b)
```

```
10
20
```

æ­¤é»˜è®¤å€¼ç»Ÿä¸€é€‚ç”¨äºæ‰€æœ‰å‚æ•°ï¼ŒåŒ…æ‹¬`self`æ–¹æ³•çš„å‚æ•°ã€‚å½“ä¼ é€’å¤§å€¼æˆ–ä¼ é€’å¾ˆè€—èµ„æºçš„å€¼ï¼ˆå¦‚å¼•ç”¨è®¡æ•°æŒ‡é’ˆï¼‰ï¼ˆè¿™æ˜¯ Python/Mojo ç±»çš„é»˜è®¤å€¼ï¼‰æ—¶ï¼Œè¿™ä¼šæ›´æœ‰æ•ˆï¼Œå› ä¸ºä¼ é€’å‚æ•°æ—¶ä¸å¿…è°ƒç”¨å¤åˆ¶æ„é€ å‡½æ•°å’Œææ„å‡½æ•°ã€‚

å› ä¸º`fn`å‡½æ•°çš„é»˜è®¤å‚æ•°çº¦å®šæ˜¯`borrowed`ï¼Œæ‰€ä»¥ Mojo å…·æœ‰ç®€å•ä¸”ç¬¦åˆé€»è¾‘çš„ä»£ç ï¼Œé»˜è®¤æƒ…å†µä¸‹å¯ä»¥æ‰§è¡Œæ­£ç¡®çš„æ“ä½œã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¸æƒ³å¤åˆ¶æˆ–ç§»åŠ¨æ•´ä¸ª`SomethingBig`ï¼Œä»…ä»…ä¸ºäº†è°ƒç”¨`print_id()`æ–¹æ³•æˆ–è°ƒç”¨`use_something_big()`.

è¿™ç§å€Ÿç”¨å‚æ•°çº¦å®šåœ¨æŸäº›æ–¹é¢ç±»ä¼¼äº C++ ä¸­çš„å‚æ•°ä¼ é€’`const&`ï¼Œè¿™é¿å…äº†å€¼çš„å‰¯æœ¬å¹¶ç¦æ­¢è¢«è°ƒç”¨è€…ä¸­ä¿®æ”¹ã€‚ç„¶è€Œï¼Œå€Ÿç”¨çš„çº¦å®šå’Œ C++ ä¸­`const&`åœ¨ä¸¤ä¸ªé‡è¦æ–¹é¢æœ‰æ‰€ä¸åŒï¼š

1. Mojo ç¼–è¯‘å™¨å®ç°äº†ä¸€ä¸ªå€Ÿç”¨æ£€æŸ¥å™¨ï¼ˆç±»ä¼¼äº Rustï¼‰ï¼Œè¯¥æ£€æŸ¥å™¨å¯ä»¥é˜²æ­¢ä»£ç åœ¨å­˜åœ¨æœªå®Œæˆçš„ä¸å¯å˜å¼•ç”¨æ—¶åŠ¨æ€å½¢æˆå¯¹æŸä¸ªå€¼çš„å¯å˜å¼•ç”¨ï¼Œå¹¶ä¸”å®ƒå¯ä»¥é˜²æ­¢å¯¹åŒä¸€å€¼è¿›è¡Œå¤šä¸ªå¯å˜å¼•ç”¨ã€‚æ‚¨å¯ä»¥è¿›è¡Œå¤šæ¬¡å€Ÿç”¨ï¼ˆå¦‚`use_something_big`ä¸Šé¢çš„è°ƒç”¨æ‰€ç¤ºï¼‰ï¼Œä½†ä¸èƒ½é€šè¿‡å¯å˜å¼•ç”¨ä¼ é€’æŸäº›å†…å®¹å¹¶åŒæ—¶å€Ÿç”¨ã€‚ï¼ˆTODOï¼šå½“å‰æœªå¯ç”¨ï¼‰ã€‚
2. åƒ`Int`ã€`Float`å’Œ`SIMD`è¿™æ ·çš„å°å€¼ç›´æ¥åœ¨æœºå™¨å¯„å­˜å™¨ä¸­ä¼ é€’ï¼Œè€Œä¸æ˜¯é€šè¿‡é¢å¤–çš„é—´æ¥ä¼ é€’ï¼ˆè¿™æ˜¯å› ä¸ºå®ƒä»¬æ˜¯ç”¨è£…é¥°å™¨[`@register_passable`](https://docs.modular.com/mojo/programming-manual.html#register_passable-struct-decorator)å£°æ˜çš„ï¼‰ã€‚ä¸ C++ å’Œ Rust ç­‰è¯­è¨€ç›¸æ¯”ï¼Œè¿™æ˜¯ä¸€ä¸ªæ˜¾ç€çš„æ€§èƒ½å¢å¼ºï¼Œå¹¶å°†è¿™ç§ä¼˜åŒ–ä»æ¯ä¸ªè°ƒç”¨ç«™ç‚¹è½¬ç§»åˆ°å¯¹ç±»å‹è¿›è¡Œå£°æ˜ã€‚

ä¸ Rust ç±»ä¼¼ï¼ŒMojo çš„å€Ÿç”¨æ£€æŸ¥å™¨å¼ºåˆ¶æ‰§è¡Œä¸å˜é‡çš„æ’ä»–æ€§ã€‚Rust å’Œ Mojo ä¹‹é—´çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼ŒMojo ä¸éœ€è¦è°ƒç”¨æ–¹æœ‰ä¸€ä¸ªå°è®°æ¥ä¼ é€’å€Ÿç”¨ã€‚æ­¤å¤–ï¼ŒMojo åœ¨ä¼ é€’å°å€¼æ—¶æ•ˆç‡æ›´é«˜ï¼Œè€Œ Rust é»˜è®¤ç§»åŠ¨å€¼è€Œä¸æ˜¯é€šè¿‡å€Ÿç”¨ä¼ é€’å®ƒä»¬ã€‚è¿™äº›ç­–ç•¥å’Œè¯­æ³•å†³ç­–ä½¿ Mojo èƒ½å¤Ÿæä¾›æ›´æ˜“äºä½¿ç”¨çš„ç¼–ç¨‹æ¨¡å‹ã€‚

### [å¯å˜å‚æ•° ( `inout`)](#mutable-arguments-inout)

å¦ä¸€æ–¹é¢ï¼Œå¦‚æœæ‚¨å®šä¹‰ä¸€ä¸ª`fn`å‡½æ•°å¹¶å¸Œæœ›å‚æ•°å¯å˜ï¼Œåˆ™å¿…é¡»ä½¿ç”¨`inout`å…³é”®å­—å°†å‚æ•°å£°æ˜ä¸ºå¯å˜çš„ã€‚

**æç¤ºï¼š**å½“æ‚¨çœ‹åˆ°æ—¶`inout`ï¼Œè¿™æ„å‘³ç€å¯¹å‡½æ•°å†…éƒ¨å‚æ•°æ‰€åšçš„ä»»ä½•æ›´æ”¹åœ¨**å‡½æ•°å¤–éƒ¨**éƒ½æ˜¯å¯è§çš„ã€‚

è€ƒè™‘ä»¥ä¸‹ç¤ºä¾‹ï¼Œå…¶ä¸­`__iadd__`å‡½æ•°ï¼ˆå®ç°è‡ªå¢æ“ä½œï¼Œä¾‹å¦‚`x += 2`ï¼‰å°è¯•ä¿®æ”¹`self`ï¼š

```
struct MyInt:
    var value: Int
    
    fn __init__(inout self, v: Int):
        self.value = v
  
    fn __copyinit__(inout self, other: MyInt):
        self.value = other.value
        
    # self and rhs are both immutable in __add__.
    fn __add__(self, rhs: MyInt) -> MyInt:
        return MyInt(self.value + rhs.value)

    # ... but this cannot work for __iadd__
    # Uncomment to see the error:
    #fn __iadd__(self, rhs: Int):
    #    self = self + rhs  # ERROR: cannot assign to self!
```

å¦‚æœå–æ¶ˆæ³¨é‡Šè¯¥`__iadd__()`æ–¹æ³•ï¼Œæ‚¨å°†æ”¶åˆ°ç¼–è¯‘å™¨é”™è¯¯ã€‚

è¿™é‡Œçš„é—®é¢˜æ˜¯`self` æ˜¯ä¸å¯å˜çš„ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ª Mojo`fn`å‡½æ•°ï¼Œæ‰€ä»¥å®ƒä¸èƒ½æ”¹å˜å‚æ•°çš„å†…éƒ¨çŠ¶æ€ï¼ˆé»˜è®¤å‚æ•°çº¦å®šæ˜¯`borrowed`ï¼‰ã€‚`inout`è§£å†³æ–¹æ¡ˆæ˜¯é€šè¿‡åœ¨`self`å‚æ•°åç§°ä¸Šæ·»åŠ å…³é”®å­—æ¥å£°æ˜å‚æ•°æ˜¯å¯å˜çš„ï¼š

```
struct MyInt:
    var value: Int
    
    fn __init__(inout self, v: Int):
        self.value = v

    fn __copyinit__(inout self, other: MyInt):
        self.value = other.value
        
    # self and rhs are both immutable in __add__.
    fn __add__(self, rhs: MyInt) -> MyInt:
        return MyInt(self.value + rhs.value)
        
    # ... now this works:
    fn __iadd__(inout self, rhs: Int):
        self = self + rhs
```

ç°åœ¨`self`å‚æ•°åœ¨å‡½æ•°ä¸­æ˜¯å¯å˜çš„ï¼Œå¹¶ä¸”ä»»ä½•æ›´æ”¹åœ¨è°ƒç”¨è€…ä¸­éƒ½æ˜¯å¯è§çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ‰§è¡Œå°±åœ°åŠ æ³•`MyInt`ï¼š

```
var x: MyInt = 42
x += 1
print(x.value) # prints 43 as expected

# However...
let y = x
# Uncomment to see the error:
# y += 1       # ERROR: Cannot mutate 'let' value
```

```
43
```

å¦‚æœå–æ¶ˆæ³¨é‡Šä¸Šé¢çš„æœ€åä¸€è¡Œï¼Œåˆ™`let`å€¼çš„ä¿®æ”¹ä¼šå¤±è´¥ï¼Œå› ä¸ºä¸å¯èƒ½å½¢æˆå¯¹ä¸å¯å˜å€¼çš„å¯å˜å¼•ç”¨ï¼ˆ`let`ä½¿å˜é‡ä¸å¯å˜ï¼‰ã€‚

å½“ç„¶ï¼Œæ‚¨å¯ä»¥å£°æ˜å¤šä¸ª`inout`å‚æ•°ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥åƒè¿™æ ·å®šä¹‰å’Œä½¿ç”¨äº¤æ¢å‡½æ•°ï¼š

```
fn swap(inout lhs: Int, inout rhs: Int):
    let tmp = lhs
    lhs = rhs
    rhs = tmp

var x = 42
var y = 12
print(x, y)  # Prints 42, 12
swap(x, y)
print(x, y)  # Prints 12, 42
```

```
42 12
12 42
```

è¯¥ç³»ç»Ÿçš„ä¸€ä¸ªéå¸¸é‡è¦çš„æ–¹é¢æ˜¯å®ƒçš„æ‰€æœ‰ç»„æˆéƒ½æ˜¯æ­£ç¡®çš„ã€‚

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä¸å°†æ­¤å‚æ•°ç§°ä¸ºâ€œé€šè¿‡å¼•ç”¨â€ä¼ é€’ã€‚å°½ç®¡`inout`çº¦å®šåœ¨æ¦‚å¿µä¸Šæ˜¯ç›¸åŒçš„ï¼Œä½†æˆ‘ä»¬ä¸å°†å…¶ç§°ä¸ºæŒ‰å¼•ç”¨ä¼ é€’ï¼Œå› ä¸ºå®ç°å®é™…ä¸Šå¯èƒ½ä½¿ç”¨æŒ‡é’ˆä¼ é€’å€¼ã€‚

### [ä¼ é€’å‚æ•° (`owned`å’Œ`^`)](#transfer-arguments-owned-and)

Mojo æ”¯æŒçš„æœ€åä¸€ä¸ªå‚æ•°çº¦å®šæ˜¯`owned`ã€‚æ­¤çº¦å®šç”¨äºæƒ³è¦è·å¾—å€¼çš„ç‹¬å æ‰€æœ‰æƒçš„å‡½æ•°ï¼Œå¹¶ä¸”é€šå¸¸ä¸åç¼€è¿ç®—`^`ç¬¦ä¸€èµ·ä½¿ç”¨ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾æ‚¨æ­£åœ¨ä½¿ç”¨ä»…ç§»åŠ¨ç±»å‹ï¼Œä¾‹å¦‚å”¯ä¸€æŒ‡é’ˆï¼š

```
# This is not really a unique pointer, we just model its behavior here
# to serve the examples below.
struct UniquePointer:
    var ptr: Int
    
    fn __init__(inout self, ptr: Int):
        self.ptr = ptr
    
    fn __moveinit__(inout self, owned existing: Self):
        self.ptr = existing.ptr
        
    fn __del__(owned self):
        self.ptr = 0
```

è™½ç„¶è¯¥`borrow`çº¦å®šä½¿å¾—æ— éœ€ä»ªå¼å³å¯è½»æ¾ä½¿ç”¨è¿™ä¸ªç‹¬ç‰¹çš„æŒ‡é’ˆï¼Œä½†åœ¨æŸäº›æ—¶å€™æ‚¨å¯èƒ½å¸Œæœ›å°†æ‰€æœ‰æƒè½¬ç§»ç»™æŸäº›å…¶ä»–å‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨éœ€è¦`^`å¯¹å¯ç§»åŠ¨ç±»å‹ä½¿ç”¨â€œä¼ è¾“â€æ“ä½œç¬¦ã€‚

è¿ç®—`^`ç¬¦ç»“æŸå€¼ç»‘å®šçš„ç”Ÿå‘½å‘¨æœŸï¼Œå¹¶å°†å€¼æ‰€æœ‰æƒè½¬ç§»ç»™å…¶ä»–ï¼ˆåœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œæ‰€æœ‰æƒè½¬ç§»ç»™å‡½æ•°`take_ptr()`ï¼‰ã€‚ä¸ºäº†æ”¯æŒè¿™ä¸€ç‚¹ï¼Œæ‚¨å¯ä»¥å°†å‡½æ•°å®šä¹‰ä¸ºæ¥å—`owned`å‚æ•°ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥å®šä¹‰`take_ptr()`è·å–å‚æ•°çš„æ‰€æœ‰æƒï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```
fn take_ptr(owned p: UniquePointer):
    print("take_ptr")
    print(p.ptr)

fn use_ptr(borrowed p: UniquePointer):
    print("use_ptr")
    print(p.ptr)
    
fn work_with_unique_ptrs():
    let p = UniquePointer(100)
    use_ptr(p)    # Pass to borrowing function.
    take_ptr(p^)  # Pass ownership of the `p` value to another function.

    # Uncomment to see an error:
    # use_ptr(p) # ERROR: p is no longer valid here!

work_with_unique_ptrs()
```

```
use_ptr
100
take_ptr
100
```

è¯·æ³¨æ„ï¼Œå¦‚æœå–æ¶ˆå¯¹ç¬¬äºŒæ¬¡è°ƒç”¨çš„æ³¨é‡Š`use_ptr()`ï¼Œåˆ™ä¼šæ”¶åˆ°é”™è¯¯ï¼Œå› ä¸ºè¯¥`p`å€¼å·²ä¼ è¾“åˆ°è¯¥`take_ptr()`å‡½æ•°ï¼Œå› æ­¤è¯¥`p`å€¼è¢«é”€æ¯ã€‚

å› ä¸ºå®ƒå·²è¢«å£°æ˜`owned`ï¼Œæ‰€ä»¥è¯¥`take_ptr()`å‡½æ•°çŸ¥é“å®ƒå…·æœ‰å¯¹è¯¥å€¼çš„å”¯ä¸€è®¿é—®æƒã€‚è¿™å¯¹äºè¯¸å¦‚å”¯ä¸€æŒ‡é’ˆä¹‹ç±»çš„äº‹æƒ…éå¸¸é‡è¦ï¼Œå¹¶ä¸”å½“æ‚¨æƒ³è¦é¿å…å¤åˆ¶æ—¶å®ƒå¾ˆæœ‰ç”¨ã€‚

ä¾‹å¦‚ï¼Œæ‚¨å°†ç‰¹åˆ«çœ‹åˆ°`owned`å…³äºææ„å‡½æ•°å’Œæ¶ˆè€—ç§»åŠ¨åˆå§‹å€¼è®¾å®šé¡¹çš„çº¦å®šã€‚ä¾‹å¦‚ï¼Œ`HeapArray`ç»“æ„ä½“åœ¨å…¶`__del__()`æ–¹æ³•ä¸­ä½¿ç”¨`owned`ï¼Œå› ä¸ºéœ€è¦æ‹¥æœ‰ä¸€ä¸ªå€¼æ‰èƒ½é”€æ¯å®ƒï¼ˆæˆ–è€…åœ¨ç§»åŠ¨æ„é€ å‡½æ•°çš„æƒ…å†µä¸‹çªƒå–è¿™éƒ¨åˆ†ï¼‰ã€‚

### æ¯”è¾ƒ`def`å’Œ`fn`å‚æ•°ä¼ é€’[](#comparing-def-and-fn-argument-passing)

Mojo çš„`def`å‡½æ•°æœ¬è´¨ä¸Šåªæ˜¯ä¸º`fn`å‡½æ•°åŠ ç³–ï¼š

* æ²¡æœ‰æ˜¾å¼ç±»å‹æ³¨é‡Šçš„å‚æ•°`def`é»˜è®¤ä¸º`Object`.
* `def`æ²¡æœ‰çº¦å®šå…³é”®å­—ï¼ˆä¾‹å¦‚`inout`æˆ–`owned`ï¼‰çš„å‚æ•°é€šè¿‡éšå¼å¤åˆ¶ä¼ é€’åˆ°ä¸å‚æ•°åŒåçš„å¯å˜å˜é‡ä¸­ã€‚ï¼ˆè¿™è¦æ±‚è¯¥ç±»å‹æœ‰ä¸€ä¸ª`__copyinit__`æ–¹æ³•ã€‚ï¼‰

ä¾‹å¦‚ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°å…·æœ‰ç›¸åŒçš„è¡Œä¸ºï¼š

```
def example(inout a: Int, b: Int, c):
    # b and c use value semantics so they're mutable in the function
    ...

fn example(inout a: Int, b_in: Int, c_in: Object):
    # b_in and c_in are immutable references, so we make mutable shadow copies
    var b = b_in
    var c = c_in
    ...
```

å·å½±å‰¯æœ¬é€šå¸¸ä¸ä¼šå¢åŠ å¼€é”€ï¼Œå› ä¸ºåƒè¿™æ ·çš„å°ç±»å‹çš„å¼•ç”¨`Object`å¤åˆ¶èµ·æ¥å¾ˆä¾¿å®œã€‚æ˜‚è´µçš„éƒ¨åˆ†æ˜¯è°ƒæ•´å¼•ç”¨è®¡æ•°ï¼Œä½†è¿™å¯ä»¥é€šè¿‡ç§»åŠ¨ä¼˜åŒ–æ¥æ¶ˆé™¤ã€‚

## Pythoné›†æˆ[](#python-integration)

åœ¨ Mojo ä¸­ä½¿ç”¨æ‚¨ç†Ÿæ‚‰å’Œå–œçˆ±çš„ Python æ¨¡å—éå¸¸ç®€å•ã€‚æ‚¨å¯ä»¥å°†ä»»ä½• Python æ¨¡å—å¯¼å…¥åˆ° Mojo ç¨‹åºä¸­ï¼Œå¹¶ä» Mojo ç±»å‹åˆ›å»º Python ç±»å‹ã€‚

### å¯¼å…¥Pythonæ¨¡å—[](#importing-python-modules)

è¦åœ¨ Mojo ä¸­å¯¼å…¥ Python æ¨¡å—ï¼Œåªéœ€`Python.import_module()`ä½¿ç”¨æ¨¡å—åç§°è¿›è¡Œè°ƒç”¨ï¼š

```
from python import Python

# This is equivalent to Python's `import numpy as np`
let np = Python.import_module("numpy")

# Now use numpy as if writing in Python
array = np.array([1, 2, 3])
print(array)
```

```
[1 2 3]
```

æ˜¯çš„ï¼Œè¿™ä¼šå¯¼å…¥ Python NumPyï¼Œå¹¶ä¸”æ‚¨å¯ä»¥å¯¼å…¥*ä»»ä½•å…¶ä»– Python æ¨¡å—*ã€‚

ç›®å‰ï¼Œæ‚¨æ— æ³•å¯¼å…¥å•ä¸ªæˆå‘˜ï¼ˆä¾‹å¦‚å•ä¸ª Python ç±»æˆ–å‡½æ•°ï¼‰ï¼Œæ‚¨å¿…é¡»å¯¼å…¥æ•´ä¸ª Python æ¨¡å—ï¼Œç„¶åé€šè¿‡æ¨¡å—åç§°è®¿é—®æˆå‘˜ã€‚

### Python ä¸­çš„ Mojo ç±»å‹[](#mojo-types-in-python)

Mojo åŸå§‹ç±»å‹éšå¼è½¬æ¢ä¸º Python å¯¹è±¡ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬æ”¯æŒåˆ—è¡¨ã€å…ƒç»„ã€æ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”å€¼å’Œå­—ç¬¦ä¸²ã€‚

ä¾‹å¦‚ï¼Œç»™å®šè¿™ä¸ªæ‰“å° Python ç±»å‹çš„ Python å‡½æ•°ï¼š

```
%%python
def type_printer(my_list, my_tuple, my_int, my_string, my_float):
    print(type(my_list))
    print(type(my_tuple))
    print(type(my_int))
    print(type(my_string))
    print(type(my_float))
```

æ‚¨å¯ä»¥æ¯«æ— é—®é¢˜åœ°ä¼ é€’ Python å‡½æ•° Mojo ç±»å‹ï¼š

```
type_printer([0, 3], (False, True), 4, "orange", 3.4)
```

```
<class 'list'>
<class 'tuple'>
<class 'int'>
<class 'str'>
<class 'float'>
```

è¯·æ³¨æ„ï¼Œåœ¨ Jupyter ç¬”è®°æœ¬ä¸­ï¼Œä¸Šé¢å£°æ˜çš„ Python å‡½æ•°å¯è‡ªåŠ¨ä¾›ä»¥ä¸‹ä»£ç å•å…ƒä¸­çš„ä»»ä½• Mojo ä»£ç ä½¿ç”¨ã€‚

Mojo è¿˜æ²¡æœ‰æ ‡å‡†å­—å…¸ï¼Œå› æ­¤è¿˜æ— æ³•ä» Mojo å­—å…¸åˆ›å»º Python å­—å…¸ã€‚ä¸è¿‡ï¼Œæ‚¨å¯ä»¥åœ¨ Mojo ä¸­ä½¿ç”¨ Python å­—å…¸ï¼è¦åˆ›å»º Python å­—å…¸ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹`dict`æ–¹æ³•ï¼š

```
from python import Python
from python.object import PythonObject

var dictionary = Python.dict()
dictionary["fruit"] = "apple"
dictionary["starch"] = "potato"

var keys: PythonObject = ["fruit", "starch", "protein"]
var N: Int = keys.__len__().__index__()
print(N, "items")

for i in range(N):
    if Python.is_type(dictionary.get(keys[i]), Python.none()):
        print(keys[i], "is not in dictionary")
    else:
        print(keys[i], "is included")
```

```
3 items
fruit is included
starch is included
protein is not in dictionary
```

#### å¯¼å…¥æœ¬åœ°Pythonæ¨¡å—[](#importing-local-python-modules)

å¦‚æœæ‚¨æƒ³åœ¨ Mojo ä¸­ä½¿ç”¨ä¸€äº›æœ¬åœ° Python ä»£ç ï¼Œåªéœ€å°†ç›®å½•æ·»åŠ åˆ° Python è·¯å¾„ï¼Œç„¶åå¯¼å…¥æ¨¡å—å³å¯ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾æ‚¨æœ‰ä¸€ä¸ªåä¸ºçš„ Python æ–‡ä»¶`mypython.py`ï¼š

```
import numpy as np

def my_algorithm(a, b):
    array_a = np.random.rand(a, a)
    return array_a + b
```

ä»¥ä¸‹æ˜¯å¯¼å…¥å®ƒå¹¶åœ¨ Mojo æ–‡ä»¶ä¸­ä½¿ç”¨å®ƒçš„æ–¹æ³•ï¼š

```
from python import Python

Python.add_to_path("path/to/module")
let mypython = Python.import_module("mypython")

let c = mypython.my_algorithm(2, 3)
print(c)
```

åœ¨ Mojo ä¸­ä½¿ç”¨ Python æ—¶æ— éœ€æ‹…å¿ƒå†…å­˜ç®¡ç†é—®é¢˜ã€‚ä¸€åˆ‡éƒ½æ­£å¸¸ï¼Œå› ä¸º Mojo ä»ä¸€å¼€å§‹å°±æ˜¯ä¸º Python è®¾è®¡çš„ã€‚

## å‚æ•°åŒ–ï¼šç¼–è¯‘æ—¶å…ƒç¼–ç¨‹[](#parameterization-compile-time-metaprogramming)

Python æœ€ä»¤äººæƒŠå¥‡çš„åŠŸèƒ½ä¹‹ä¸€æ˜¯å…¶å¯æ‰©å±•çš„è¿è¡Œæ—¶å…ƒç¼–ç¨‹åŠŸèƒ½ã€‚è¿™ä½¿å¾—å¹¿æ³›çš„åº“æˆä¸ºå¯èƒ½ï¼Œå¹¶æä¾›äº†çµæ´»ä¸”å¯æ‰©å±•çš„ç¼–ç¨‹æ¨¡å‹ï¼Œä¸–ç•Œå„åœ°çš„ Python ç¨‹åºå‘˜éƒ½å¯ä»¥ä»ä¸­å—ç›Šã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™äº›åŠŸèƒ½ä¹Ÿæ˜¯æœ‰ä»£ä»·çš„ï¼šå› ä¸ºå®ƒä»¬æ˜¯åœ¨è¿è¡Œæ—¶è¯„ä¼°çš„ï¼Œæ‰€ä»¥å®ƒä»¬ç›´æ¥å½±å“åº•å±‚ä»£ç çš„è¿è¡Œæ—¶æ•ˆç‡ã€‚ç”±äº IDE ä¸çŸ¥é“å®ƒä»¬ï¼Œå› æ­¤ä»£ç å®Œæˆç­‰ IDE åŠŸèƒ½å¾ˆéš¾ç†è§£å®ƒä»¬å¹¶ä½¿ç”¨å®ƒä»¬æ¥æ”¹å–„å¼€å‘äººå‘˜ä½“éªŒã€‚

åœ¨Pythonç”Ÿæ€ç³»ç»Ÿä¹‹å¤–ï¼Œé™æ€å…ƒç¼–ç¨‹ä¹Ÿæ˜¯å¼€å‘çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œå¯ä»¥å¼€å‘æ–°çš„ç¼–ç¨‹èŒƒä¾‹å’Œé«˜çº§åº“ã€‚è¿™ä¸ªé¢†åŸŸæœ‰è®¸å¤šç°æœ‰æŠ€æœ¯çš„ä¾‹å­ï¼Œå…·æœ‰ä¸åŒçš„æƒè¡¡ï¼Œä¾‹å¦‚ï¼š

1. é¢„å¤„ç†å™¨ï¼ˆä¾‹å¦‚C é¢„å¤„ç†å™¨ã€Lex/YACC ç­‰ï¼‰å¯èƒ½æ˜¯æœ€ç¹é‡çš„ã€‚å®ƒä»¬å®Œå…¨é€šç”¨ï¼Œä½†åœ¨å¼€å‘äººå‘˜ä½“éªŒå’Œå·¥å…·é›†æˆæ–¹é¢æœ€å·®ã€‚
2. ä¸€äº›è¯­è¨€ï¼ˆå¦‚ Lisp å’Œ Rustï¼‰æ”¯æŒï¼ˆæœ‰æ—¶æ˜¯â€œå«ç”Ÿçš„â€ï¼‰å®æ‰©å±•åŠŸèƒ½ï¼Œé€šè¿‡æ›´å¥½çš„å·¥å…·é›†æˆå®ç°è¯­æ³•æ‰©å±•å’Œæ ·æ¿æ–‡ä»¶å‡å°‘ã€‚
3. _ä¸€äº›è¾ƒæ—§çš„è¯­è¨€ï¼ˆä¾‹å¦‚ C++ï¼‰å…·æœ‰éå¸¸åºå¤§ä¸”å¤æ‚çš„å…ƒç¼–ç¨‹è¯­è¨€ï¼ˆæ¨¡æ¿ï¼‰ï¼Œå®ƒä»¬æ˜¯è¿è¡Œæ—¶_è¯­è¨€çš„åŒé‡è¯­è¨€ã€‚è¿™äº›å°¤å…¶éš¾ä»¥å­¦ä¹ ï¼Œå¹¶ä¸”ç¼–è¯‘æ—¶é—´å’Œé”™è¯¯æ¶ˆæ¯éƒ½å¾ˆå·®ã€‚
4. æœ‰äº›è¯­è¨€ï¼ˆå¦‚ Swiftï¼‰ä»¥ä¸€æµçš„æ–¹å¼å°†è®¸å¤šåŠŸèƒ½æ„å»ºåˆ°æ ¸å¿ƒè¯­è¨€ä¸­ï¼Œä¸ºå¸¸è§æƒ…å†µæä¾›è‰¯å¥½çš„äººä½“å·¥ç¨‹å­¦æ•ˆæœï¼Œä½†ç‰ºç‰²äº†é€šç”¨æ€§ã€‚
5. ä¸€äº›è¾ƒæ–°çš„è¯­è¨€ï¼ˆä¾‹å¦‚ Zigï¼‰å°†è¯­è¨€è§£é‡Šå™¨é›†æˆåˆ°ç¼–è¯‘æµç¨‹ä¸­ï¼Œå¹¶å…è®¸è§£é‡Šå™¨åœ¨ç¼–è¯‘ AST æ—¶è¿›è¡Œåæ˜ ã€‚è¿™ä½¿å¾—è®¸å¤šä¸å®ç³»ç»Ÿç›¸åŒçš„åŠŸèƒ½å…·æœ‰æ›´å¥½çš„æ‰©å±•æ€§å’Œé€šç”¨æ€§ã€‚

å¯¹äº Modular åœ¨äººå·¥æ™ºèƒ½ã€é«˜æ€§èƒ½æœºå™¨å­¦ä¹ å†…æ ¸å’ŒåŠ é€Ÿå™¨æ–¹é¢çš„å·¥ä½œï¼Œæˆ‘ä»¬éœ€è¦å…ˆè¿›çš„å…ƒç¼–ç¨‹ç³»ç»Ÿæä¾›çš„é«˜æŠ½è±¡èƒ½åŠ›ã€‚æˆ‘ä»¬éœ€è¦é«˜çº§çš„é›¶æˆæœ¬æŠ½è±¡ã€å¯Œæœ‰è¡¨ç°åŠ›çš„åº“ä»¥åŠå¤šç§ç®—æ³•å˜ä½“çš„å¤§è§„æ¨¡é›†æˆã€‚æˆ‘ä»¬å¸Œæœ›åº“å¼€å‘äººå‘˜èƒ½å¤Ÿæ‰©å±•ç³»ç»Ÿï¼Œå°±åƒä»–ä»¬åœ¨ Python ä¸­æ‰€åšçš„é‚£æ ·ï¼Œæä¾›ä¸€ä¸ªå¯æ‰©å±•çš„å¼€å‘å¹³å°ã€‚

ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬ä¸æ„¿æ„ç‰ºç‰²å¼€å‘äººå‘˜ä½“éªŒï¼ˆåŒ…æ‹¬ç¼–è¯‘æ—¶é—´å’Œé”™è¯¯æ¶ˆæ¯ï¼‰ï¼Œä¹Ÿæ²¡æœ‰å…´è¶£æ„å»ºéš¾ä»¥æ•™æˆçš„å¹¶è¡Œè¯­è¨€ç”Ÿæ€ç³»ç»Ÿã€‚æˆ‘ä»¬å¯ä»¥å‘è¿™äº›ä»¥å‰çš„ç³»ç»Ÿå­¦ä¹ ï¼Œä½†ä¹Ÿå¯ä»¥åœ¨å…¶åŸºç¡€ä¸Šæ„å»ºæ–°æŠ€æœ¯ï¼ŒåŒ…æ‹¬ MLIR å’Œç»†ç²’åº¦è¯­è¨€é›†æˆç¼“å­˜æŠ€æœ¯ã€‚

å› æ­¤ï¼ŒMojo æ”¯æŒç¼–è¯‘å™¨ä¸­å†…ç½®çš„ç¼–è¯‘æ—¶å…ƒç¼–ç¨‹ï¼Œä½œä¸ºç¼–è¯‘çš„ä¸€ä¸ªå•ç‹¬é˜¶æ®µâ€”â€”åœ¨è§£æã€è¯­ä¹‰åˆ†æå’Œ IR ç”Ÿæˆä¹‹åï¼Œä½†åœ¨é™ä½åˆ°ç‰¹å®šäºç›®æ ‡çš„ä»£ç ä¹‹å‰ã€‚å®ƒå¯¹è¿è¡Œæ—¶ç¨‹åºä½¿ç”¨ä¸å…ƒç¨‹åºç›¸åŒçš„å®¿ä¸»è¯­è¨€ï¼Œå¹¶åˆ©ç”¨ MLIR ä»¥å¯é¢„æµ‹çš„æ–¹å¼è¡¨ç¤ºå’Œè¯„ä¼°è¿™äº›ç¨‹åºã€‚

è®©æˆ‘ä»¬çœ‹ä¸€äº›ç®€å•çš„ä¾‹å­ã€‚

**å…³äºâ€œå‚æ•°â€ï¼š** Python å¼€å‘äººå‘˜å¯ä»¥äº’æ¢åœ°ä½¿ç”¨â€œå‚æ•°â€å’Œâ€œå‚æ•°â€è¿™ä¸¤ä¸ªè¯æ¥è¡¨ç¤ºâ€œä¼ é€’åˆ°å‡½æ•°ä¸­çš„ä¸œè¥¿â€ã€‚æˆ‘ä»¬å†³å®šå›æ”¶â€œå‚æ•°â€å’Œâ€œå‚æ•°è¡¨è¾¾å¼â€æ¥è¡¨ç¤º Mojo ä¸­çš„ç¼–è¯‘æ—¶å€¼ï¼Œå¹¶ç»§ç»­ä½¿ç”¨â€œå‚æ•°â€å’Œâ€œè¡¨è¾¾å¼â€æ¥å¼•ç”¨è¿è¡Œæ—¶å€¼ã€‚è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿå›´ç»•â€œå‚æ•°åŒ–â€å’Œâ€œå‚æ•°åŒ–â€ç­‰è¯è¿›è¡Œå¯¹é½ï¼Œä»¥è¿›è¡Œç¼–è¯‘æ—¶å…ƒç¼–ç¨‹ã€‚

### å®šä¹‰å‚æ•°åŒ–ç±»å‹å’Œå‡½æ•°[](#defining-parameterized-types-and-functions)

[æ‚¨å¯ä»¥é€šè¿‡åœ¨æ–¹æ‹¬å·ä¸­æŒ‡å®šå‚æ•°åç§°å’Œç±»å‹æ¥å‚æ•°åŒ–ç»“æ„å’Œå‡½æ•°ï¼ˆä½¿ç”¨PEP695 è¯­æ³•](https://peps.python.org/pep-0695/)çš„æ‰©å±•ç‰ˆæœ¬ï¼‰ã€‚[ä¸å‚æ•°å€¼ä¸åŒï¼Œå‚æ•°å€¼åœ¨ç¼–è¯‘æ—¶æ˜¯å·²çŸ¥çš„ï¼Œè¿™å¯ä»¥å®ç°é¢å¤–çº§åˆ«çš„æŠ½è±¡å’Œä»£ç é‡ç”¨ï¼Œä»¥åŠè‡ªåŠ¨è°ƒæ•´](https://docs.modular.com/mojo/programming-manual.html#autotuning-adaptive-compilation)ç­‰ç¼–è¯‘å™¨ä¼˜åŒ–ã€‚

ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬çœ‹ä¸€ä¸‹[SIMD](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data)ç±»å‹ï¼Œå®ƒè¡¨ç¤ºç¡¬ä»¶ä¸­ä¿å­˜æ ‡é‡æ•°æ®ç±»å‹çš„å¤šä¸ªå®ä¾‹çš„ä½çº§å‘é‡å¯„å­˜å™¨ã€‚ç¡¬ä»¶åŠ é€Ÿå™¨ä¸æ–­å¼•å…¥æ–°çš„å‘é‡æ•°æ®ç±»å‹ï¼Œç”šè‡³CPUä¹Ÿå¯èƒ½æœ‰512ä½æˆ–æ›´é•¿çš„SIMDå‘é‡ã€‚ä¸ºäº†è®¿é—®è¿™äº›å¤„ç†å™¨ä¸Šçš„ SIMD æŒ‡ä»¤ï¼Œå¿…é¡»å°†æ•°æ®æ•´å½¢ä¸ºæ­£ç¡®çš„ SIMD å®½åº¦ï¼ˆæ•°æ®ç±»å‹ï¼‰å’Œé•¿åº¦ï¼ˆå‘é‡å¤§å°ï¼‰ã€‚

ç„¶è€Œï¼Œç”¨ Mojo çš„å†…ç½®ç±»å‹å®šä¹‰æ‰€æœ‰ä¸åŒçš„ SIMD å˜ä½“æ˜¯ä¸å¯è¡Œçš„ã€‚å› æ­¤ï¼ŒMojo çš„`SIMD`ç±»å‹ï¼ˆå®šä¹‰ä¸ºç»“æ„ï¼‰åœ¨å…¶æ–¹æ³•ä¸­å…¬å¼€äº†å¸¸è§çš„ SIMD æ“ä½œï¼Œå¹¶ä½¿ SIMD æ•°æ®ç±»å‹å’Œå¤§å°å€¼å‚æ•°åŒ–ã€‚è¿™ä½¿æ‚¨å¯ä»¥å°†æ•°æ®ç›´æ¥æ˜ å°„åˆ°ä»»ä½•ç¡¬ä»¶ä¸Šçš„ SIMD å‘é‡ã€‚

è¿™æ˜¯ Mojo ç±»å‹å®šä¹‰çš„ç²¾ç®€ï¼ˆéåŠŸèƒ½ï¼‰ç‰ˆæœ¬`SIMD`ï¼š

```
struct SIMD[type: DType, size: Int]:
    var value: â€¦ # Some low-level MLIR stuff here

    # Create a new SIMD from a number of scalars
    fn __init__(inout self, *elems: SIMD[type, 1]):  ...

    # Fill a SIMD with a duplicated scalar value.
    @staticmethod
    fn splat(x: SIMD[type, 1]) -> SIMD[type, size]: ...

    # Cast the elements of the SIMD to a different elt type.
    fn cast[target: DType](self) -> SIMD[target, size]: ...

    # Many standard operators are supported.
    fn __add__(self, rhs: Self) -> Self: ...
```

ä½¿ç”¨å‚æ•°å®šä¹‰æ¯ä¸ª SIMD å˜ä½“éå¸¸æœ‰åˆ©äºä»£ç é‡ç”¨ï¼Œå› ä¸ºè¯¥`SIMD`ç±»å‹å¯ä»¥é™æ€åœ°è¡¨è¾¾æ‰€æœ‰ä¸åŒçš„å‘é‡å˜ä½“ï¼Œè€Œä¸éœ€è¦è¯­è¨€é¢„å…ˆå®šä¹‰æ¯ä¸ªå˜ä½“ã€‚

å› ä¸º`SIMD`æ˜¯å‚æ•°åŒ–ç±»å‹ï¼Œæ‰€ä»¥`self`å…¶å‡½æ•°ä¸­çš„å®å‚æºå¸¦è¿™äº›å‚æ•°â€”â€”å®Œæ•´çš„ç±»å‹åç§°æ˜¯`SIMD[type, size]`ã€‚å°½ç®¡å°†å…¶å†™å‡ºæ˜¯æœ‰æ•ˆçš„ï¼ˆå¦‚ çš„è¿”å›ç±»å‹æ‰€ç¤º`splat()`ï¼‰ï¼Œä½†è¿™å¯èƒ½ä¼šå¾ˆå†—é•¿ï¼Œå› æ­¤æˆ‘ä»¬å»ºè®®åƒç¤ºä¾‹ä¸€æ ·ä½¿ç”¨è¯¥`Self`ç±»å‹ï¼ˆæ¥è‡ª[PEP673](https://peps.python.org/pep-0673/)ï¼‰`__add__`ã€‚

### å‚æ•°é‡è½½[](#overloading-on-parameters)

å‡½æ•°å’Œæ–¹æ³•å¯ä»¥åœ¨å…¶å‚æ•°ç­¾åä¸Šé‡è½½ã€‚é‡è½½å†³ç­–é€»è¾‘æ ¹æ®ä»¥ä¸‹è§„åˆ™ï¼ˆæŒ‰ä¼˜å…ˆé¡ºåºï¼‰è¿‡æ»¤å€™é€‰è€…ï¼š

1. å…·æœ‰æœ€å°‘æ•°é‡éšå¼è½¬æ¢ï¼ˆåœ¨å®å‚å’Œå‚æ•°ä¸­ï¼‰çš„å€™é€‰è€…ã€‚
2. æ²¡æœ‰å¯å˜å‚æ•°çš„å€™é€‰äººã€‚
3. æ²¡æœ‰å¯å˜å‚æ•°çš„å€™é€‰è€…ã€‚
4. å…·æœ‰æœ€çŸ­å‚æ•°ç­¾åçš„å€™é€‰è€…ã€‚

å¦‚æœåº”ç”¨è¿™äº›è§„åˆ™åå­˜åœ¨å¤šä¸ªå€™é€‰è€…ï¼Œåˆ™é‡è½½å†³ç­–å°†å¤±è´¥ã€‚ä¾‹å¦‚ï¼š

```
@register_passable("trivial")
struct MyInt:
    """A type that is implicitly convertible to `Int`."""
    var value: Int

    @always_inline("nodebug")
    fn __init__(_a: Int) -> Self:
        return Self {value: _a}

fn foo[x: MyInt, a: Int]():
  print("foo[x: MyInt, a: Int]()")

fn foo[x: MyInt, y: MyInt]():
  print("foo[x: MyInt, y: MyInt]()")

fn bar[a: Int](b: Int):
  print("bar[a: Int](b: Int)")

fn bar[a: Int](*b: Int):
  print("bar[a: Int](*b: Int)")

fn bar[*a: Int](b: Int):
  print("bar[*a: Int](b: Int)")

fn parameter_overloads[a: Int, b: Int, x: MyInt]():
    # `foo[x: MyInt, a: Int]()` is called because it requires no implicit
    # conversions, whereas `foo[x: MyInt, y: MyInt]()` requires one.
    foo[x, a]()

    # `bar[a: Int](b: Int)` is called because it does not have variadic
    # arguments or parameters.
    bar[a](b)

    # `bar[*a: Int](b: Int)` is called because it has variadic parameters.
    bar[a, a, a](b)

parameter_overloads[1, 2, MyInt(3)]()
```

```
foo[x: MyInt, a: Int]()
bar[a: Int](b: Int)
bar[*a: Int](b: Int)
```

### ä½¿ç”¨å‚æ•°åŒ–ç±»å‹å’Œå‡½æ•°[](#using-parameterized-types-and-functions)

æ‚¨å¯ä»¥é€šè¿‡å°†å€¼ä¼ é€’ç»™æ–¹æ‹¬å·ä¸­çš„å‚æ•°æ¥å®ä¾‹åŒ–å‚æ•°ç±»å‹å’Œå‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¯¹äº`SIMD`ä¸Šé¢çš„ç±»å‹ï¼Œ`type`æŒ‡å®šæ•°æ®ç±»å‹å¹¶`size`æŒ‡å®šSIMDå‘é‡çš„é•¿åº¦ï¼ˆå¿…é¡»æ˜¯2çš„å¹‚ï¼‰ï¼š

```
# Make a vector of 4 floats.
let small_vec = SIMD[DType.float32, 4](1.0, 2.0, 3.0, 4.0)

# Make a big vector containing 1.0 in float16 format.
let big_vec = SIMD[DType.float16, 32].splat(1.0)

# Do some math and convert the elements to float32.
let bigger_vec = (big_vec+big_vec).cast[DType.float32]()

# You can write types out explicitly if you want of course.
let bigger_vec2 : SIMD[DType.float32, 32] = bigger_vec

print('small_vec type:', small_vec.element_type, 'length:', len(small_vec))
print('bigger_vec2 type:', bigger_vec2.element_type, 'length:', len(bigger_vec2))
```

```
small_vec type: float32 length: 4
bigger_vec2 type: float32 length: 32
```

è¯·æ³¨æ„ï¼Œè¯¥`cast()`æ–¹æ³•è¿˜éœ€è¦ä¸€ä¸ªå‚æ•°æ¥æŒ‡å®šæ‚¨æƒ³è¦çš„ç±»å‹è½¬æ¢ï¼ˆä¸Šé¢çš„æ–¹æ³•å®šä¹‰éœ€è¦ä¸€ä¸ª`target`å‚æ•°å€¼ï¼‰ã€‚`SIMD`å› æ­¤ï¼Œå°±åƒç»“æ„æ˜¯æ³›å‹ç±»å‹å®šä¹‰ä¸€æ ·ï¼Œ`cast()`æ–¹æ³•ä¹Ÿæ˜¯æ³›å‹æ–¹æ³•å®šä¹‰ï¼Œå®ƒæ ¹æ®å‚æ•°å€¼åœ¨ç¼–è¯‘æ—¶è€Œä¸æ˜¯è¿è¡Œæ—¶å®ä¾‹åŒ–ã€‚

ä¸Šé¢çš„ä»£ç æ˜¾ç¤ºäº†å…·ä½“ç±»å‹çš„ä½¿ç”¨ï¼ˆå³ï¼Œå®ƒ`SIMD`ä½¿ç”¨å·²çŸ¥ç±»å‹å€¼è¿›è¡Œå®ä¾‹åŒ–ï¼‰ï¼Œä½†å‚æ•°çš„ä¸»è¦åŠŸèƒ½æ¥è‡ªäºå®šä¹‰å‚æ•°ç®—æ³•å’Œç±»å‹ï¼ˆä½¿ç”¨å‚æ•°å€¼çš„ä»£ç ï¼‰çš„èƒ½åŠ›ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯å¦‚ä½•å®šä¹‰ä¸`SIMD`ç±»å‹å’Œå®½åº¦æ— å…³çš„å‚æ•°ç®—æ³•ï¼š

```
from math import sqrt

fn rsqrt[dt: DType, width: Int](x: SIMD[dt, width]) -> SIMD[dt, width]:
    return 1 / sqrt(x)

print(rsqrt[DType.float16, 4](42))
```

```
[0.154296875, 0.154296875, 0.154296875, 0.154296875]
```

è¯·æ³¨æ„ï¼Œ`x`å‚æ•°å®é™…ä¸Šæ˜¯`SIMD`åŸºäºå‡½æ•°å‚æ•°çš„ç±»å‹ã€‚è¿è¡Œæ—¶ç¨‹åºå¯ä»¥ä½¿ç”¨å‚æ•°çš„å€¼ï¼Œå› ä¸ºå‚æ•°åœ¨è¿è¡Œæ—¶ç¨‹åºéœ€è¦å®ƒä»¬ä¹‹å‰åœ¨ç¼–è¯‘æ—¶è§£æï¼ˆä½†ç¼–è¯‘æ—¶å‚æ•°è¡¨è¾¾å¼ä¸èƒ½ä½¿ç”¨è¿è¡Œæ—¶å€¼ï¼‰ã€‚

Mojo ç¼–è¯‘å™¨å¯¹äºå‚æ•°çš„ç±»å‹æ¨æ–­ä¹Ÿå¾ˆæ™ºèƒ½ã€‚è¯·æ³¨æ„ï¼Œä¸Šè¿°å‡½æ•°æ— éœ€[`sqrt()`](https://docs.modular.com/mojo/MojoStdlib/Math.html#sqrt)æŒ‡å®šå‚æ•°å³å¯è°ƒç”¨å‚æ•°å‡½æ•° - ç¼–è¯‘å™¨ä¼šæ¨æ–­å…¶å‚æ•°ï¼Œå°±åƒæ‚¨`sqrt[type, simd_width](x)`æ˜¾å¼ç¼–å†™ä¸€æ ·ã€‚å¦è¯·æ³¨æ„ï¼Œ`rsqrt()`é€‰æ‹©å®šä¹‰å…¶ç¬¬ä¸€ä¸ªå‚æ•° name ï¼Œ`width`å³ä½¿`SIMD`ç±»å‹å°†å…¶å‘½åä¸º it `size`ï¼Œä¹Ÿæ²¡æœ‰é—®é¢˜ã€‚

### å‚æ•°è¡¨è¾¾å¼åªæ˜¯ Mojo ä»£ç [](#parameter-expressions-are-just-mojo-code)

`a+b`å‚æ•°è¡¨è¾¾å¼æ˜¯å‡ºç°åœ¨éœ€è¦å‚æ•°çš„ä½ç½®çš„ä»»ä½•ä»£ç è¡¨è¾¾å¼ï¼ˆä¾‹å¦‚ï¼‰ã€‚å‚æ•°è¡¨è¾¾å¼æ”¯æŒè¿ç®—ç¬¦å’Œå‡½æ•°è°ƒç”¨ï¼Œå°±åƒè¿è¡Œæ—¶ä»£ç ä¸€æ ·ï¼Œå¹¶ä¸”æ‰€æœ‰å‚æ•°ç±»å‹éƒ½ä½¿ç”¨ä¸è¿è¡Œæ—¶ç¨‹åºç›¸åŒçš„ç±»å‹ç³»ç»Ÿï¼ˆä¾‹å¦‚`Int`å’Œ`DType`ï¼‰ã€‚

ç”±äºå‚æ•°è¡¨è¾¾å¼ä½¿ç”¨ä¸è¿è¡Œæ—¶ Mojo ä»£ç ç›¸åŒçš„è¯­æ³•å’Œç±»å‹ï¼Œå› æ­¤æ‚¨å¯ä»¥ä½¿ç”¨è®¸å¤šâ€œä¾èµ–ç±»å‹â€åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯èƒ½æƒ³è¦å®šä¹‰ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥è¿æ¥ä¸¤ä¸ª SIMD å‘é‡ï¼š

```
fn concat[ty: DType, len1: Int, len2: Int](
        lhs: SIMD[ty, len1], rhs: SIMD[ty, len2]) -> SIMD[ty, len1+len2]:

    var result = SIMD[ty, len1 + len2]()
    for i in range(len1):
        result[i] = SIMD[ty, 1](lhs[i])
    for j in range(len2):
        result[len1 + j] = SIMD[ty, 1](rhs[j])
    return result

let a = SIMD[DType.float32, 2](1, 2)
let x = concat[DType.float32, 2, 2](a, a)

print('result type:', x.element_type, 'length:', len(x))
```

```
result type: float32 length: 4
```

è¯·æ³¨æ„ï¼Œç»“æœé•¿åº¦æ˜¯è¾“å…¥å‘é‡é•¿åº¦çš„æ€»å’Œï¼Œæ‚¨å¯ä»¥é€šè¿‡ç®€å•çš„`+`æ“ä½œæ¥è¡¨è¾¾å®ƒã€‚å¯¹äºæ›´å¤æ‚çš„ç¤ºä¾‹ï¼Œè¯·çœ‹ä¸€ä¸‹[`SIMD.shuffle()`](https://docs.modular.com/mojo/MojoStdlib/SIMD.html#shuffle)æ ‡å‡†åº“ä¸­çš„æ–¹æ³•ï¼šå®ƒæ¥å—ä¸¤ä¸ªè¾“å…¥ SIMD å€¼ã€ä¸€ä¸ªå‘é‡æ´—ç‰Œæ©ç ä½œä¸ºåˆ—è¡¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªä¸æ´—ç‰Œæ©ç é•¿åº¦åŒ¹é…çš„ SIMDã€‚

### å¼ºå¤§çš„ç¼–è¯‘æ—¶ç¼–ç¨‹[](#powerful-compile-time-programming)

è™½ç„¶ç®€å•çš„è¡¨è¾¾å¼å¾ˆæœ‰ç”¨ï¼Œä½†æœ‰æ—¶æ‚¨å¸Œæœ›ä½¿ç”¨æ§åˆ¶æµç¼–å†™å‘½ä»¤å¼ç¼–è¯‘æ—¶é€»è¾‘ã€‚ä¾‹å¦‚ï¼Œ`isclose()`Mojo`Math`æ¨¡å—ä¸­çš„å‡½æ•°å¯¹æ•´æ•°ä½¿ç”¨ç²¾ç¡®ç›¸ç­‰ï¼Œä½†å¯¹æµ®ç‚¹ä½¿ç”¨â€œæ¥è¿‘â€æ¯”è¾ƒã€‚æ‚¨ç”šè‡³å¯ä»¥è¿›è¡Œç¼–è¯‘æ—¶é€’å½’ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹â€œæ ‘ç¼©å‡â€ç®—æ³•ï¼Œå®ƒå°†å‘é‡çš„æ‰€æœ‰å…ƒç´ é€’å½’åœ°æ±‚å’Œä¸ºæ ‡é‡ï¼š

```
fn slice[ty: DType, new_size: Int, size: Int](
        x: SIMD[ty, size], offset: Int) -> SIMD[ty, new_size]:
    var result = SIMD[ty, new_size]()
    for i in range(new_size):
        result[i] = SIMD[ty, 1](x[i + offset])
    return result

fn reduce_add[ty: DType, size: Int](x: SIMD[ty, size]) -> Int:
    @parameter
    if size == 1:
        return x[0].to_int()
    elif size == 2:
        return x[0].to_int() + x[1].to_int()

    # Extract the top/bottom halves, add them, sum the elements.
    alias half_size = size // 2
    let lhs = slice[ty, half_size, size](x, 0)
    let rhs = slice[ty, half_size, size](x, half_size)
    return reduce_add[ty, half_size](lhs + rhs)
    
let x = SIMD[DType.index, 4](1, 2, 3, 4)
print(x)
print("Elements sum:", reduce_add[DType.index, 4](x))
```

```
[1, 2, 3, 4]
Elements sum: 10
```

è¿™åˆ©ç”¨äº†è¯¥`@parameter if`åŠŸèƒ½ï¼Œå³`if`åœ¨ç¼–è¯‘æ—¶è¿è¡Œçš„è¯­å¥ã€‚å®ƒè¦æ±‚å…¶æ¡ä»¶æ˜¯æœ‰æ•ˆçš„å‚æ•°è¡¨è¾¾å¼ï¼Œå¹¶ç¡®ä¿åªæœ‰è¯­å¥çš„å®æ—¶åˆ†æ”¯`if`è¢«ç¼–è¯‘åˆ°ç¨‹åºä¸­ã€‚

### Mojo ç±»å‹åªæ˜¯å‚æ•°è¡¨è¾¾å¼[](#mojo-types-are-just-parameter-expressions)

è™½ç„¶æˆ‘ä»¬å·²ç»å±•ç¤ºäº†å¦‚ä½•åœ¨ç±»å‹ä¸­ä½¿ç”¨å‚æ•°è¡¨è¾¾å¼ï¼Œä½†ç±»å‹æ³¨é‡Šæœ¬èº«å¯ä»¥æ˜¯ä»»æ„è¡¨è¾¾å¼ï¼ˆå°±åƒåœ¨ Python ä¸­ä¸€æ ·ï¼‰ã€‚Mojo ä¸­çš„ç±»å‹å…·æœ‰ç‰¹æ®Šçš„å…ƒç±»å‹ï¼Œå…è®¸å®šä¹‰ç±»å‹å‚æ•°ç®—æ³•å’Œå‡½æ•°ã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ª`Array`æ”¯æŒä»»æ„ç±»å‹å…ƒç´ çš„ç®€åŒ–ç‰ˆæœ¬ï¼ˆé€šè¿‡`AnyType`å‚æ•°ï¼‰ï¼š

```
struct Array[T: AnyType]:
    var data: Pointer[T]
    var size: Int

    fn __init__(inout self, size: Int, value: T):
        self.size = size
        self.data = Pointer[T].alloc(self.size)
        for i in range(self.size):
            self.data.store(i, value)
              
    fn __getitem__(self, i: Int) -> T:
        return self.data.load(i)

    fn __del__(owned self):
        self.data.free()

var v = Array[Float32](4, 3.14)
print(v[0], v[1], v[2], v[3])
```

```
3.1400001049041748 3.1400001049041748 3.1400001049041748 3.1400001049041748
```

è¯·æ³¨æ„ï¼Œ`T`å‚æ•°è¢«ç”¨ä½œå‚æ•°çš„å½¢å¼ç±»å‹`value`å’Œå‡½æ•°çš„è¿”å›ç±»å‹`__getitem__`ã€‚å‚æ•°å…è®¸`Array`ç±»å‹æ ¹æ®ä¸åŒçš„ç”¨ä¾‹æä¾›ä¸åŒçš„ APIã€‚

è¿˜æœ‰è®¸å¤šå…¶ä»–æƒ…å†µå¯ä»¥ä»å‚æ•°çš„æ›´é«˜çº§ä½¿ç”¨ä¸­å—ç›Šã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥å¹¶è¡Œæ‰§è¡Œé—­åŒ… N æ¬¡ï¼Œå¹¶ä»ä¸Šä¸‹æ–‡ä¸­è¾“å…¥ä¸€ä¸ªå€¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```
fn parallelize[func: fn (Int) -> None](num_work_items: Int):
    # Not actually parallel: see the 'algorithm' module for real implementation.
    for i in range(num_work_items):
        func(i)
```

å¦ä¸€ä¸ªé‡è¦çš„ä¾‹å­æ˜¯å¯å˜å‚æ•°æ³›å‹ï¼Œå…¶ä¸­å¯èƒ½éœ€è¦åœ¨å¼‚æ„ç±»å‹åˆ—è¡¨ä¸Šå®šä¹‰ç®—æ³•æˆ–æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚å…ƒç»„ï¼š

```
struct Tuple[*Ts: AnyType]:
    var _storage : *Ts
```

å°½ç®¡æˆ‘ä»¬è¿˜æ²¡æœ‰è¶³å¤Ÿçš„å…ƒç±»å‹åŠ©æ‰‹ï¼Œä½†æˆ‘ä»¬å°†æ¥åº”è¯¥èƒ½å¤Ÿç¼–å†™ç±»ä¼¼çš„ä¸œè¥¿ï¼ˆå°½ç®¡é‡è½½ä»ç„¶æ˜¯å¤„ç†æ­¤é—®é¢˜çš„æ›´å¥½æ–¹æ³•ï¼‰ï¼š

```
struct Array[T: AnyType]:
    fn __getitem__[IndexType: AnyType](self, idx: IndexType)
       -> (ArraySlice[T] if issubclass(IndexType, Range) else T):
       ...
```

### `alias`: å‘½åå‚æ•°è¡¨è¾¾å¼[](#alias-named-parameter-expressions)

æƒ³è¦_å‘½å_ç¼–è¯‘æ—¶å€¼æ˜¯å¾ˆå¸¸è§çš„ã€‚è™½ç„¶`var`å®šä¹‰äº†è¿è¡Œæ—¶å€¼å¹¶`let`å®šä¹‰äº†è¿è¡Œæ—¶å¸¸é‡ï¼Œä½†æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥å®šä¹‰ç¼–è¯‘æ—¶ä¸´æ—¶å€¼ã€‚ä¸ºæ­¤ï¼ŒMojo ä½¿ç”¨`alias`å£°æ˜ã€‚

ä¾‹å¦‚ï¼Œè¯¥`DType`ç»“æ„ä½¿ç”¨æšä¸¾å™¨çš„åˆ«åå®ç°ä¸€ä¸ªç®€å•çš„æšä¸¾ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼ˆå®é™…`DType`å®ç°ç»†èŠ‚ç•¥æœ‰ä¸åŒï¼‰ï¼š

```
struct DType:
    var value : UI8
    alias invalid = DType(0)
    alias bool = DType(1)
    alias int8 = DType(2)
    alias uint8 = DType(3)
    alias int16 = DType(4)
    alias int16 = DType(5)
    ...
    alias float32 = DType(15)
```

è¿™å…è®¸å®¢æˆ·ç«¯è‡ªç„¶åœ°ç”¨ä½œ`DType.float32`å‚æ•°è¡¨è¾¾å¼ï¼ˆä¹Ÿå¯ä»¥ç”¨ä½œè¿è¡Œæ—¶å€¼ï¼‰ã€‚`DType`è¯·æ³¨æ„ï¼Œè¿™æ˜¯åœ¨ç¼–è¯‘æ—¶è°ƒç”¨è¿è¡Œæ—¶æ„é€ å‡½æ•°ã€‚

ç±»å‹æ˜¯åˆ«åçš„å¦ä¸€ä¸ªå¸¸è§ç”¨é€”ã€‚å› ä¸ºç±»å‹æ˜¯ç¼–è¯‘æ—¶è¡¨è¾¾å¼ï¼Œæ‰€ä»¥èƒ½å¤Ÿå¾ˆæ–¹ä¾¿åœ°æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

```
alias Float16 = SIMD[DType.float16, 1]
alias UInt8 = SIMD[DType.uint8, 1]

var x : Float16   # FLoat16 works like a "typedef"
```

ä¸`var`å’Œä¸€æ ·`let`ï¼Œåˆ«åéµå¾ªèŒƒå›´ï¼Œå¹¶ä¸”æ‚¨å¯ä»¥æŒ‰ç…§é¢„æœŸåœ¨å‡½æ•°ä¸­ä½¿ç”¨æœ¬åœ°åˆ«åã€‚

é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œ å’Œ`None`éƒ½`AnyType`è¢«å®šä¹‰ä¸º[ç±»å‹åˆ«å](https://docs.modular.com/mojo/MojoBuiltin/TypeAliases.html)ã€‚

### è‡ªåŠ¨è°ƒæ•´/è‡ªé€‚â€‹â€‹åº”ç¼–è¯‘[](#autotuning-adaptive-compilation)

Mojo å‚æ•°è¡¨è¾¾å¼å…è®¸æ‚¨åƒåœ¨å…¶ä»–è¯­è¨€ä¸­ä¸€æ ·ç¼–å†™å¯ç§»æ¤çš„å‚æ•°ç®—æ³•ï¼Œä½†æ˜¯åœ¨ç¼–å†™é«˜æ€§èƒ½ä»£ç æ—¶ï¼Œæ‚¨ä»ç„¶å¿…é¡»é€‰æ‹©ç”¨äºå‚æ•°çš„å…·ä½“å€¼ã€‚ä¾‹å¦‚ï¼Œåœ¨ç¼–å†™é«˜æ€§èƒ½æ•°å€¼ç®—æ³•æ—¶ï¼Œæ‚¨å¯èƒ½å¸Œæœ›ä½¿ç”¨å†…å­˜å¹³é“ºæ¥åŠ é€Ÿç®—æ³•ï¼Œä½†è¦ä½¿ç”¨çš„ç»´åº¦åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå–å†³äºå¯ç”¨çš„ç¡¬ä»¶åŠŸèƒ½ã€ç¼“å­˜çš„å¤§å°ã€èåˆåˆ°å†…æ ¸ä¸­çš„å†…å®¹ä»¥åŠè®¸å¤šå…¶ä»–ç¹ççš„ç»†èŠ‚ã€‚

å³ä½¿å‘é‡é•¿åº¦ä¹Ÿå¯èƒ½éš¾ä»¥ç®¡ç†ï¼Œå› ä¸ºå…¸å‹æœºå™¨çš„å‘é‡é•¿åº¦å–å†³äºæ•°æ®ç±»å‹ï¼Œå¹¶ä¸”æŸäº›æ•°æ®ç±»å‹`bfloat16`å¹¶ä¸å®Œå…¨æ”¯æŒæ‰€æœ‰å®ç°ã€‚Mojo é€šè¿‡`autotune`åœ¨æ ‡å‡†åº“ä¸­æä¾›ä¸€ä¸ªå‡½æ•°æ¥æä¾›å¸®åŠ©ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æƒ³å°†ä¸å‘é‡é•¿åº¦æ— å…³çš„ç®—æ³•å†™å…¥æ•°æ®ç¼“å†²åŒºï¼Œæ‚¨å¯ä»¥è¿™æ ·ç¼–å†™ï¼š

```
from autotune import autotune, search
from benchmark import Benchmark
from memory.unsafe import DTypePointer
from algorithm import vectorize

fn buffer_elementwise_add_impl[
    dt: DType
](lhs: DTypePointer[dt], rhs: DTypePointer[dt], result: DTypePointer[dt], N: Int):
    """Perform elementwise addition of N elements in RHS and LHS and store
    the result in RESULT.
    """
    @parameter
    fn add_simd[size: Int](idx: Int):
        let lhs_simd = lhs.simd_load[size](idx)
        let rhs_simd = rhs.simd_load[size](idx)
        result.simd_store[size](idx, lhs_simd + rhs_simd)
    
    # Pick vector length for this dtype and hardware
    alias vector_len = autotune(1, 4, 8, 16, 32)

    # Use it as the vectorization length
    vectorize[vector_len, add_simd](N)

fn elementwise_evaluator[dt: DType](
    fns: Pointer[fn (DTypePointer[dt], DTypePointer[dt], DTypePointer[dt], Int) -> None],
    num: Int,
) -> Int:
    # Benchmark the implementations on N = 64.
    alias N = 64
    let lhs = DTypePointer[dt].alloc(N)
    let rhs = DTypePointer[dt].alloc(N)
    let result = DTypePointer[dt].alloc(N)

    # Fill with ones.
    for i in range(N):
        lhs.store(i, 1)
        rhs.store(i, 1)

    # Find the fastest implementation.
    var best_idx: Int = -1
    var best_time: Int = -1
    for i in range(num):
        @parameter
        fn wrapper():
            fns.load(i)(lhs, rhs, result, N)
        let cur_time = Benchmark(1).run[wrapper]()
        if best_idx < 0 or best_time > cur_time:
            best_idx = i
            best_time = cur_time
        print("time[", i, "] =", cur_time)
    print("selected:", best_idx)
    return best_idx

fn buffer_elementwise_add[
    dt: DType
](lhs: DTypePointer[dt], rhs: DTypePointer[dt], result: DTypePointer[dt], N: Int):
    # Forward declare the result parameter.
    alias best_impl: fn(DTypePointer[dt], DTypePointer[dt], DTypePointer[dt], Int) -> None

    # Perform search!
    search[
      fn(DTypePointer[dt], DTypePointer[dt], DTypePointer[dt], Int) -> None,
      buffer_elementwise_add_impl[dt],
      elementwise_evaluator[dt] -> best_impl
    ]()

    # Call the select implementation
    best_impl(lhs, rhs, result, N)
```

æˆ‘ä»¬ç°åœ¨å¯ä»¥åƒå¾€å¸¸ä¸€æ ·è°ƒç”¨æˆ‘ä»¬çš„å‡½æ•°ï¼š

```
let N = 32
let a = DTypePointer[DType.float32].alloc(N)
let b = DTypePointer[DType.float32].alloc(N)
let res = DTypePointer[DType.float32].alloc(N)
# Initialize arrays with some values
for i in range(N):
    a.store(i, 2.0)
    b.store(i, 40.0)
    res.store(i, -1)
    
buffer_elementwise_add[DType.float32](a, b, res, N)
print(a.load(10), b.load(10), res.load(10))
```

```
time[ 0 ] = 23
time[ 1 ] = 6
time[ 2 ] = 4
time[ 3 ] = 3
time[ 4 ] = 4
selected: 3
2.0 40.0 42.0
```

ç¼–è¯‘æ­¤ä»£ç çš„å®ä¾‹æ—¶ï¼ŒMojo ä¼šåˆ†å‰æ­¤ç®—æ³•çš„ç¼–è¯‘ï¼Œå¹¶é€šè¿‡æµ‹é‡åœ¨å®è·µä¸­æœ€é€‚åˆç›®æ ‡ç¡¬ä»¶çš„å€¼æ¥å†³å®šä½¿ç”¨å“ªä¸ªå€¼ã€‚å®ƒè¯„ä¼°è¡¨è¾¾å¼çš„ä¸åŒå€¼`vector_len`ï¼Œå¹¶æ ¹æ®ç”¨æˆ·å®šä¹‰çš„æ€§èƒ½è¯„ä¼°å™¨é€‰æ‹©æœ€å¿«çš„å€¼ã€‚ä¾‹å¦‚ï¼Œå› ä¸ºå®ƒå•ç‹¬æµ‹é‡å’Œè¯„ä¼°æ¯ä¸ªé€‰é¡¹ï¼Œæ‰€ä»¥å®ƒå¯èƒ½ä¼šä¸º`float32`é€‰å–ä¸åŒçš„å‘é‡é•¿åº¦ã€‚`int8`è¿™ä¸ªç®€å•çš„åŠŸèƒ½éå¸¸å¼ºå¤§â€”â€”è¶…è¶Šäº†ç®€å•çš„æ•´æ•°å¸¸é‡â€”â€”å› ä¸ºå‡½æ•°å’Œç±»å‹ä¹Ÿæ˜¯å‚æ•°è¡¨è¾¾å¼ã€‚

è¯·æ³¨æ„ï¼Œæœ€ä½³å‘é‡é•¿åº¦çš„æœç´¢æ˜¯ç”±è¯¥[`search()`](https://docs.modular.com/mojo/stdlib/autotune/autotuning.html#search)å‡½æ•°æ‰§è¡Œçš„ã€‚`search()`æ¥å—ä¸€ä¸ªè¯„ä¼°å™¨å’Œä¸€ä¸ªåˆ†å‰å‡½æ•°ï¼Œå¹¶è¿”å›è¯„ä¼°å™¨é€‰æ‹©çš„æœ€å¿«å®ç°ä½œä¸ºå‚æ•°ç»“æœã€‚[è¦æ›´æ·±å…¥åœ°äº†è§£æ­¤ä¸»é¢˜ï¼Œè¯·æŸ¥çœ‹æœ‰å…³Mojo ä¸­çš„](https://docs.modular.com/mojo/notebooks/Memset.html)[çŸ©é˜µä¹˜æ³•](https://docs.modular.com/mojo/notebooks/Matmul.html)å’ŒFast Memsetçš„ç¬”è®°æœ¬ã€‚[](https://docs.modular.com/mojo/notebooks/Memset.html)

è‡ªåŠ¨è°ƒä¼˜æœ¬è´¨ä¸Šæ˜¯ä¸€ç§æŒ‡æ•°æŠ€æœ¯ï¼Œå—ç›Šäº Mojo ç¼–è¯‘å™¨å †æ ˆçš„å†…éƒ¨å®ç°ç»†èŠ‚ï¼ˆç‰¹åˆ«æ˜¯ MLIRã€é›†æˆç¼“å­˜å’Œç¼–è¯‘åˆ†å‘ï¼‰ã€‚è¿™ä¹Ÿæ˜¯ä¸€ä¸ªé«˜çº§ç”¨æˆ·åŠŸèƒ½ï¼Œéœ€è¦éšç€æ—¶é—´çš„æ¨ç§»ä¸æ–­å¼€å‘å’Œè¿­ä»£ã€‚

## â€œä»·å€¼ç”Ÿå‘½å‘¨æœŸâ€ï¼šä»·å€¼çš„è¯ç”Ÿã€å­˜åœ¨å’Œæ¶ˆäº¡[](#value-lifecycle-birth-life-and-death-of-a-value)

æ­¤æ—¶ï¼Œæ‚¨åº”è¯¥äº†è§£ Mojo å‡½æ•°å’Œç±»å‹çš„æ ¸å¿ƒè¯­ä¹‰å’ŒåŠŸèƒ½ï¼Œå› æ­¤æˆ‘ä»¬ç°åœ¨å¯ä»¥è®¨è®ºå®ƒä»¬å¦‚ä½•ç»„åˆåœ¨ä¸€èµ·ä»¥åœ¨ Mojo ä¸­è¡¨è¾¾æ–°ç±»å‹ã€‚

è®¸å¤šç°æœ‰è¯­è¨€éƒ½é€šè¿‡ä¸åŒçš„æƒè¡¡æ¥è¡¨è¾¾è®¾è®¡ç‚¹ï¼šä¾‹å¦‚ï¼ŒC++ éå¸¸å¼ºå¤§ï¼Œä½†ç»å¸¸è¢«æŒ‡è´£â€œé»˜è®¤è®¾ç½®é”™è¯¯â€ï¼Œä»è€Œå¯¼è‡´é”™è¯¯å’Œé”™è¯¯åŠŸèƒ½ã€‚Swift æ˜“äºä½¿ç”¨ï¼Œä½†å…¶æ¨¡å‹çš„å¯é¢„æµ‹æ€§è¾ƒå·®ï¼Œä¼šå¤åˆ¶å¤§é‡å€¼ï¼Œå¹¶ä¸”ä¾èµ–äºâ€œARC ä¼˜åŒ–å™¨â€æ¥æé«˜æ€§èƒ½ã€‚Rust ä»å¼ºå¤§çš„ä»·å€¼æ‰€æœ‰æƒç›®æ ‡å¼€å§‹ï¼Œä»¥æ»¡è¶³å…¶å€Ÿç”¨æ£€æŸ¥å™¨çš„è¦æ±‚ï¼Œä½†ä¾èµ–äºå¯ç§»åŠ¨çš„å€¼ï¼Œè¿™ä½¿å¾—è¡¨è¾¾è‡ªå®šä¹‰ç§»åŠ¨æ„é€ å‡½æ•°å˜å¾—å…·æœ‰æŒ‘æˆ˜æ€§ï¼Œå¹¶ä¸”ä¼šç»™æ€§èƒ½å¸¦æ¥å¾ˆå¤§çš„å‹åŠ›`memcpy`ã€‚åœ¨Pythonä¸­ï¼Œä¸€åˆ‡éƒ½æ˜¯å¯¹ç±»çš„å¼•ç”¨ï¼Œå› æ­¤å®ƒæ°¸è¿œä¸ä¼šçœŸæ­£é¢ä¸´ç±»å‹é—®é¢˜ã€‚

å¯¹äº Mojoï¼Œæˆ‘ä»¬ä»è¿™äº›ç°æœ‰ç³»ç»Ÿä¸­å­¦ä¹ ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯æä¾›ä¸€ä¸ªéå¸¸å¼ºå¤§ä¸”æ˜“äºå­¦ä¹ å’Œç†è§£çš„æ¨¡å‹ã€‚æˆ‘ä»¬ä¹Ÿä¸æƒ³è¦æ±‚â€œå°½æœ€å¤§åŠªåŠ›â€å’Œéš¾ä»¥é¢„æµ‹çš„ä¼˜åŒ–è¿‡ç¨‹å†…ç½®åˆ°â€œè¶³å¤Ÿæ™ºèƒ½â€çš„ç¼–è¯‘å™¨ä¸­ã€‚

ä¸ºäº†æ¢ç´¢è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬ç ”ç©¶äº†ä¸åŒçš„ä»·å€¼åˆ†ç±»å’Œè¡¨è¾¾å®ƒä»¬çš„ç›¸å…³ Mojo åŠŸèƒ½ï¼Œå¹¶è‡ªä¸‹è€Œä¸Šæ„å»ºã€‚æˆ‘ä»¬åœ¨ç¤ºä¾‹ä¸­ä½¿ç”¨ C++ ä½œä¸ºä¸»è¦æ¯”è¾ƒç‚¹ï¼Œå› ä¸ºå®ƒä¼—æ‰€å‘¨çŸ¥ï¼Œä½†å¦‚æœå…¶ä»–è¯­è¨€æä¾›äº†æ›´å¥½çš„æ¯”è¾ƒç‚¹ï¼Œæˆ‘ä»¬å¶å°”ä¼šå‚è€ƒå®ƒä»¬ã€‚

### æ— æ³•å®ä¾‹åŒ–çš„ç±»å‹[](#types-that-cannot-be-instantiated)

Mojo ä¸­æœ€ç®€å•çš„ç±»å‹æ˜¯ä¸å…è®¸åˆ›å»ºå®ƒçš„å®ä¾‹çš„ç±»å‹ï¼šè¿™äº›ç±»å‹æ ¹æœ¬æ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ï¼Œå¦‚æœå®ƒä»¬æœ‰ææ„å‡½æ•°ï¼Œåˆ™æ°¸è¿œä¸ä¼šè°ƒç”¨å®ƒï¼ˆå› ä¸ºæ— æ³•é”€æ¯å®ä¾‹ï¼‰ ï¼‰ï¼š

```
struct NoInstances:
    var state: Int  # Pretty useless

    alias my_int = Int

    @staticmethod
    fn print_hello():
        print("hello world")
```

Mojo ç±»å‹é»˜è®¤æƒ…å†µä¸‹ä¸ä¼šè·å¾—é»˜è®¤æ„é€ å‡½æ•°ã€ç§»åŠ¨æ„é€ å‡½æ•°ã€æˆå‘˜åˆå§‹åŒ–å™¨æˆ–å…¶ä»–ä»»ä½•å†…å®¹ï¼Œå› æ­¤ä¸å¯èƒ½åˆ›å»ºæ­¤`NoInstances`ç±»å‹çš„å®ä¾‹ã€‚ä¸ºäº†è·å¾—å®ƒä»¬ï¼Œæ‚¨éœ€è¦å®šä¹‰ä¸€ä¸ª`__init__`æ–¹æ³•æˆ–ä½¿ç”¨åˆæˆåˆå§‹åŒ–ç¨‹åºçš„è£…é¥°å™¨ã€‚å¦‚å›¾æ‰€ç¤ºï¼Œè¿™äº›ç±»å‹å¯ç”¨ä½œâ€œå‘½åç©ºé—´â€ï¼Œå› ä¸ºæ‚¨å¯ä»¥å¼•ç”¨é™æ€æˆå‘˜ï¼Œä¾‹å¦‚`NoInstances.my_int`æˆ–`NoInstances.print_hello()`å³ä½¿æ‚¨æ— æ³•å®ä¾‹åŒ–è¯¥ç±»å‹çš„å®ä¾‹ã€‚

### ä¸å¯ç§»åŠ¨å’Œä¸å¯å¤åˆ¶ç±»å‹[](#non-movable-and-non-copyable-types)

å¦‚æœæˆ‘ä»¬åœ¨å¤æ‚æ€§çš„é˜¶æ¢¯ä¸Šæ›´è¿›ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†å¾—åˆ°å¯ä»¥å®ä¾‹åŒ–çš„ç±»å‹ï¼Œä½†æ˜¯ä¸€æ—¦å®ƒä»¬è¢«å›ºå®šåˆ°å†…å­˜ä¸­çš„åœ°å€ï¼Œå®ƒä»¬å°±ä¸èƒ½è¢«éšå¼ç§»åŠ¨æˆ–å¤åˆ¶ã€‚è¿™å¯¹äºå®ç°åŸå­æ“ä½œï¼ˆä¾‹å¦‚`std::atomic`åœ¨ C++ ä¸­ï¼‰ç­‰ç±»å‹æˆ–å…¶ä»–ç±»å‹éå¸¸æœ‰ç”¨ï¼Œå…¶ä¸­å€¼çš„å†…å­˜åœ°å€æ˜¯å…¶æ ‡è¯†å¹¶ä¸”å¯¹å…¶ç”¨é€”è‡³å…³é‡è¦ï¼š

```
struct Atomic:
    var state: Int

    fn __init__(inout self, state: Int = 0):
        self.state = state

    fn __iadd__(inout self, rhs: Int):
        #...atomic magic...

    fn get_value(self) -> Int:
        return atomic_load_int(self.state)
```

æ­¤ç±»å®šä¹‰äº†ä¸€ä¸ªåˆå§‹åŒ–ç¨‹åºï¼Œä½†æ²¡æœ‰å¤åˆ¶æˆ–ç§»åŠ¨æ„é€ å‡½æ•°ï¼Œå› æ­¤ä¸€æ—¦åˆå§‹åŒ–ï¼Œå°±æ°¸è¿œæ— æ³•ç§»åŠ¨æˆ–å¤åˆ¶ã€‚è¿™æ˜¯å®‰å…¨ä¸”æœ‰ç”¨çš„ï¼Œå› ä¸º Mojo çš„æ‰€æœ‰æƒç³»ç»Ÿæ˜¯å®Œå…¨â€œåœ°å€æ­£ç¡®çš„â€â€”â€”å½“å®ƒè¢«åˆå§‹åŒ–åˆ°å †æ ˆæˆ–å…¶ä»–ç±»å‹çš„å­—æ®µä¸­æ—¶ï¼Œå®ƒæ°¸è¿œä¸éœ€è¦ç§»åŠ¨ã€‚

è¯·æ³¨æ„ï¼ŒMojo çš„æ–¹æ³•ä»…æ§åˆ¶å†…ç½®ç§»åŠ¨æ“ä½œï¼Œä¾‹å¦‚`a = b`å¤åˆ¶å’Œ[`^`ä¼ è¾“è¿ç®—ç¬¦](https://docs.modular.com/mojo/programming-manual.html#owned-arguments)ã€‚æ‚¨å¯ä»¥ç”¨äºè‡ªå·±çš„ç±»å‹ï¼ˆå¦‚ä¸Š`Atomic`ï¼‰çš„ä¸€ç§æœ‰ç”¨æ¨¡å¼æ˜¯æ·»åŠ æ˜¾å¼`copy()`æ–¹æ³•ï¼ˆéâ€œdunderâ€æ–¹æ³•ï¼‰ã€‚å½“ç¨‹åºå‘˜çŸ¥é“å®ä¾‹æ˜¯å®‰å…¨çš„æ—¶ï¼Œè¿™å¯¹äºåˆ¶ä½œå®ä¾‹çš„æ˜¾å¼å‰¯æœ¬å¾ˆæœ‰ç”¨ã€‚

### ç‹¬ç‰¹çš„â€œä»…ç§»åŠ¨â€ç±»å‹[](#unique-move-only-types)

å¦‚æœæˆ‘ä»¬åœ¨èƒ½åŠ›çš„é˜¶æ¢¯ä¸Šå†ä¸Šä¸€å±‚æ¥¼ï¼Œæˆ‘ä»¬å°†é‡åˆ°â€œå”¯ä¸€â€çš„ç±»å‹ - C++ ä¸­æœ‰å¾ˆå¤šè¿™æ ·çš„ä¾‹å­ï¼Œä¾‹å¦‚ç±»ä¼¼çš„ç±»å‹ï¼Œç”šè‡³æ˜¯æ‹¥æœ‰åº•å±‚ POSIX æ–‡ä»¶æè¿°ç¬¦çš„`std::unique_ptr`ç±»å‹`FileDescriptor`ã€‚è¿™äº›ç±»å‹åœ¨ Rust ç­‰è¯­è¨€ä¸­å¾ˆæ™®éï¼Œä¸é¼“åŠ±å¤åˆ¶ï¼Œä½†â€œç§»åŠ¨â€æ˜¯å…è´¹çš„ã€‚`__moveinit__`åœ¨ Mojo ä¸­ï¼Œæ‚¨å¯ä»¥é€šè¿‡å®šä¹‰è·å–å”¯ä¸€ç±»å‹æ‰€æœ‰æƒçš„æ–¹æ³•æ¥å®ç°è¿™äº›ç±»å‹çš„ç§»åŠ¨ã€‚ä¾‹å¦‚ï¼š

```
# This is a simple wrapper around POSIX-style fcntl.h functions.
struct FileDescriptor:
    var fd: Int

    # This is how we move our unique type.
    fn __moveinit__(inout self, owned existing: Self):
        self.fd = existing.fd

    # This takes ownership of a POSIX file descriptor.
    fn __init__(inout self, fd: Int):
        self.fd = fd

    fn __init__(inout self, path: String):
        # Error handling omitted, call the open(2) syscall.
        self = FileDescriptor(open(path, ...))

    fn __del__(owned self):
        close(self.fd)   # pseudo code, call close(2)

    fn dup(self) -> Self:
        # Invoke the dup(2) system call.
        return Self(dup(self.fd))
    fn read(...): ...
    fn write(...): ...
```

æ¶ˆè´¹ç§»åŠ¨æ„é€ å‡½æ•° ( `__moveinit__`) è·å–ç°æœ‰ çš„æ‰€æœ‰æƒ`FileDescriptor`ï¼Œå¹¶å°†å…¶å†…éƒ¨å®ç°ç»†èŠ‚ç§»åŠ¨åˆ°æ–°å®ä¾‹ã€‚è¿™æ˜¯å› ä¸º çš„å®ä¾‹`FileDescriptor`å¯èƒ½å­˜åœ¨äºä¸åŒçš„ä½ç½®ï¼Œå¹¶ä¸”å®ƒä»¬å¯ä»¥åœ¨é€»è¾‘ä¸Šç§»åŠ¨â€”â€”çªƒå–ä¸€ä¸ªå€¼çš„ä¸»ä½“å¹¶å°†å…¶ç§»åŠ¨åˆ°å¦ä¸€ä¸ªå€¼ä¸­ã€‚

è¿™æ˜¯ä¸€ä¸ªä¼š`__moveinit__`å¤šæ¬¡è°ƒç”¨çš„ä»¤äººéœ‡æƒŠçš„ç¤ºä¾‹ï¼š

```
fn egregious_moves(owned fd1: FileDescriptor):
    # fd1 and fd2 have different addresses in memory, but the
    # transfer operator moves unique ownership from fd1 to fd2.
    let fd2 = fd1^

    # Do it again, a use of fd2 after this point will produce an error.
    let fd3 = fd2^

    # We can do this all day...
    let fd4 = fd3^
    fd4.read(...)
    # fd4.__del__() runs here
```

è¯·æ³¨æ„å¦‚ä½•ä½¿ç”¨åç¼€â€œè½¬ç§»â€è¿ç®—ç¬¦åœ¨æ‹¥æœ‰è¯¥å€¼çš„å„ä¸ªå€¼ä¹‹é—´è½¬ç§»è¯¥å€¼çš„æ‰€æœ‰æƒ`^`ï¼Œè¿™ä¼šç ´åå…ˆå‰çš„ç»‘å®šå¹¶å°†æ‰€æœ‰æƒè½¬ç§»åˆ°æ–°çš„å¸¸é‡ã€‚å¦‚æœæ‚¨ç†Ÿæ‚‰ C++ï¼Œé‚£ä¹ˆè€ƒè™‘è½¬ç§»è¿ç®—ç¬¦çš„ç®€å•æ–¹æ³•å°±åƒ`std::move`ï¼Œä½†åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å®ƒèƒ½å¤Ÿç§»åŠ¨äº‹ç‰©è€Œä¸å°†å®ƒä»¬é‡ç½®ä¸ºå¯ä»¥é”€æ¯çš„çŠ¶æ€ï¼šåœ¨ C++ ä¸­ï¼Œå¦‚æœæ‚¨ç§»åŠ¨è¿ç®—ç¬¦æ— æ³•æ›´æ”¹æ—§å€¼çš„`fd`å®ä¾‹ï¼Œå®ƒå°†è¢«å…³é—­ä¸¤æ¬¡ã€‚

Mojo è·Ÿè¸ªå€¼çš„æ´»è·ƒåº¦å¹¶å…è®¸æ‚¨å®šä¹‰è‡ªå®šä¹‰ç§»åŠ¨æ„é€ å‡½æ•°ã€‚è¿™å¾ˆå°‘éœ€è¦ï¼Œä½†ä¸€æ—¦éœ€è¦å°±éå¸¸å¼ºå¤§ã€‚ä¾‹å¦‚ï¼ŒæŸäº›ç±»å‹å–œæ¬¢[`llvm::SmallVector type`](https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h)ä½¿ç”¨â€œå†…è”å­˜å‚¨â€ä¼˜åŒ–æŠ€æœ¯ï¼Œå¹¶ä¸”å®ƒä»¬å¯èƒ½å¸Œæœ›é€šè¿‡â€œå†…éƒ¨æŒ‡é’ˆâ€æ¥å®ç°åˆ°å…¶å®ä¾‹ä¸­ã€‚è¿™æ˜¯ä¸€ä¸ªä¼—æ‰€å‘¨çŸ¥çš„æŠ€å·§ï¼Œå¯ä»¥å‡è½» malloc å†…å­˜åˆ†é…å™¨çš„å‹åŠ›ï¼Œä½†è¿™æ„å‘³ç€â€œç§»åŠ¨â€æ“ä½œéœ€è¦è‡ªå®šä¹‰é€»è¾‘æ¥åœ¨å‘ç”Ÿè¿™ç§æƒ…å†µæ—¶æ›´æ–°æŒ‡é’ˆã€‚

ä½¿ç”¨ Mojoï¼Œè¿™å°±åƒå®ç°è‡ªå®šä¹‰`__moveinit__`æ–¹æ³•ä¸€æ ·ç®€å•ã€‚è¿™åœ¨ C++ ä¸­ä¹Ÿå¾ˆå®¹æ˜“å®ç°ï¼ˆä¸è¿‡ï¼Œåœ¨ä¸éœ€è¦è‡ªå®šä¹‰é€»è¾‘çš„æƒ…å†µä¸‹å¯ä»¥ä½¿ç”¨æ ·æ¿ï¼‰ï¼Œä½†åœ¨å…¶ä»–æµè¡Œçš„å†…å­˜å®‰å…¨è¯­è¨€ä¸­å¾ˆéš¾å®ç°ã€‚

å¦ä¸€ç‚¹éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè™½ç„¶ Mojo ç¼–è¯‘å™¨æä¾›äº†è‰¯å¥½çš„å¯é¢„æµ‹æ€§å’Œæ§åˆ¶ï¼Œä½†å®ƒä¹Ÿéå¸¸å¤æ‚ã€‚å®ƒä¿ç•™æ¶ˆé™¤ä¸´æ—¶å’Œç›¸åº”çš„å¤åˆ¶/ç§»åŠ¨æ“ä½œçš„æƒåˆ©ã€‚å¦‚æœè¿™ä¸é€‚åˆæ‚¨çš„ç±»å‹ï¼Œæ‚¨åº”è¯¥ä½¿ç”¨æ˜¾å¼æ–¹æ³•ï¼ˆä¾‹å¦‚ï¼‰`copy()`è€Œä¸æ˜¯ dunder æ–¹æ³•ã€‚

### æ”¯æŒâ€œé‡‡å–è¡ŒåŠ¨â€çš„ç±»å‹[](#types-that-support-a-taking-move)

å†…å­˜å®‰å…¨è¯­è¨€é¢ä¸´çš„ä¸€ä¸ªæŒ‘æˆ˜æ˜¯ï¼Œå®ƒä»¬éœ€è¦å›´ç»•ç¼–è¯‘å™¨èƒ½å¤Ÿè·Ÿè¸ªçš„å†…å®¹æä¾›å¯é¢„æµ‹çš„ç¼–ç¨‹æ¨¡å‹ï¼Œè€Œç¼–è¯‘å™¨ä¸­çš„é™æ€åˆ†ææœ¬è´¨ä¸Šæ˜¯æœ‰é™çš„ã€‚ä¾‹å¦‚ï¼Œè™½ç„¶ç¼–è¯‘å™¨å¯ä»¥ç†è§£ä¸‹é¢ç¬¬ä¸€ä¸ªç¤ºä¾‹ä¸­çš„ä¸¤ä¸ªæ•°ç»„è®¿é—®æ˜¯é’ˆå¯¹ä¸åŒçš„æ•°ç»„å…ƒç´ ï¼Œä½†ï¼ˆé€šå¸¸ï¼‰ä¸å¯èƒ½æ¨ç†ç¬¬äºŒä¸ªç¤ºä¾‹ï¼ˆè¿™æ˜¯ C++ ä»£ç ï¼‰ï¼š

```
std::pair<T, T> getValues1(MutableArray<T> &array) {
    return { std::move(array[0]), std::move(array[1]) };
}
std::pair<T, T> getValues2(MutableArray<T> &array, size_t i, size_t j) {
    return { std::move(array[i]), std::move(array[j]) };
}
```

è¿™é‡Œçš„é—®é¢˜æ˜¯æ ¹æœ¬æ²¡æœ‰åŠæ³•ï¼ˆä»…æŸ¥çœ‹ä¸Šé¢çš„å‡½æ•°ä½“ï¼‰çŸ¥é“æˆ–è¯æ˜ å’Œ çš„åŠ¨æ€å€¼`i`ä¸`j`ç›¸åŒã€‚è™½ç„¶å¯ä»¥ç»´æŠ¤åŠ¨æ€çŠ¶æ€æ¥è·Ÿè¸ªæ•°ç»„çš„å„ä¸ªå…ƒç´ æ˜¯å¦å¤„äºæ´»åŠ¨çŠ¶æ€ï¼Œä½†è¿™é€šå¸¸ä¼šå¯¼è‡´å¤§é‡çš„è¿è¡Œæ—¶å¼€é”€ï¼ˆå³ä½¿ä¸ä½¿ç”¨ç§»åŠ¨/ä¼ è¾“ï¼‰ï¼Œè¿™æ˜¯ Mojo å’Œå…¶ä»–ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ä¸çƒ­è¡·çš„äº‹æƒ…åšã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•æœ‰å¾ˆå¤šç§ï¼ŒåŒ…æ‹¬ä¸€äº›ç›¸å½“å¤æ‚ä¸”å¹¶ä¸æ€»æ˜¯å®¹æ˜“å­¦ä¹ çš„è§£å†³æ–¹æ¡ˆã€‚

Mojo é‡‡ç”¨åŠ¡å®çš„æ–¹æ³•ï¼Œè®© Mojo ç¨‹åºå‘˜æ— éœ€å¤„ç†å…¶ç±»å‹ç³»ç»Ÿå³å¯å®Œæˆå·¥ä½œã€‚å¦‚ä¸Šæ‰€ç¤ºï¼Œå®ƒå¹¶ä¸å¼ºåˆ¶ç±»å‹å¯å¤åˆ¶ã€å¯ç§»åŠ¨ï¼Œç”šè‡³å¯æ„é€ ï¼Œä½†å®ƒç¡®å®å¸Œæœ›ç±»å‹èƒ½å¤Ÿè¡¨è¾¾å…¶å®Œæ•´å¥‘çº¦ï¼Œå¹¶ä¸”å®ƒå¸Œæœ›å®ç°ç¨‹åºå‘˜æœŸæœ›ä» C++ ç­‰è¯­è¨€ä¸­è·å¾—çš„æµç•…è®¾è®¡æ¨¡å¼ã€‚è¿™é‡Œçš„ï¼ˆä¼—æ‰€å‘¨çŸ¥çš„ï¼‰è§‚å¯Ÿæ˜¯ï¼Œè®¸å¤šå¯¹è±¡å…·æœ‰å¯ä»¥â€œæ‹¿èµ°â€çš„å†…å®¹ï¼Œè€Œæ— éœ€ç¦ç”¨å…¶ææ„å‡½æ•°ï¼Œæˆ–è€…å› ä¸ºå®ƒä»¬å…·æœ‰â€œç©ºçŠ¶æ€â€ï¼ˆå¦‚å¯é€‰ç±»å‹æˆ–å¯ä¸ºç©ºæŒ‡é’ˆï¼‰ï¼Œæˆ–è€…å› ä¸ºå®ƒä»¬å…·æœ‰ç©ºå€¼å¯ä»¥é«˜æ•ˆåœ°åˆ›å»ºå¹¶ä¸”æ— æ“ä½œå¯ä»¥é”€æ¯ï¼ˆä¾‹å¦‚ï¼ŒÂ `std::vector`å…¶æ•°æ®å¯ä»¥æœ‰ä¸€ä¸ªç©ºæŒ‡é’ˆï¼‰ã€‚

ä¸ºäº†æ”¯æŒè¿™äº›ç”¨ä¾‹ï¼Œ[`^`è½¬ç§»è¿ç®—ç¬¦](https://docs.modular.com/mojo/programming-manual.html#owned-arguments)æ”¯æŒä»»æ„å·¦å€¼ï¼Œå¹¶ä¸”å½“åº”ç”¨äºå…¶ä¸­ä¸€ä¸ªæ—¶ï¼Œå®ƒä¼šè°ƒç”¨â€œé‡‡å–ç§»åŠ¨æ„é€ å‡½æ•°â€ï¼Œæ‹¼å†™ä¸º`__takeinit__`ã€‚æ­¤æ„é€ å‡½æ•°å¿…é¡»å°†æ–°å€¼è®¾ç½®ä¸ºæ´»åŠ¨çŠ¶æ€ï¼Œå¹¶ä¸”å®ƒå¯ä»¥æ”¹å˜æ—§å€¼ï¼Œä½†å®ƒå¿…é¡»å°†æ—§å€¼ç½®äºå…¶ææ„å‡½æ•°ä»ç„¶å¯ä»¥å·¥ä½œçš„çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æƒ³å°†æˆ‘ä»¬`FileDescriptor`æ”¾å…¥ä¸€ä¸ªå‘é‡ä¸­å¹¶ç§»å‡ºå®ƒï¼Œæˆ‘ä»¬å¯èƒ½ä¼šé€‰æ‹©æ‰©å±•å®ƒä»¥çŸ¥é“å®ƒ`-1`æ˜¯ä¸€ä¸ªå“¨å…µï¼Œè¿™æ„å‘³ç€å®ƒæ˜¯â€œç©ºâ€ã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·å®ç°ï¼š

```
# This is a simple wrapper around POSIX-style fcntl.h functions.
struct FileDescriptor:
    var fd: Int

    # This is the new key capability.
    fn __takeinit__(inout self, inout existing: Self):
        self.fd = existing.fd
        existing.fd = -1  # neutralize 'existing'.

    fn __moveinit__(inout self, owned existing: Self): # as above
    fn __init__(inout self, fd: Int): # as above
    fn __init__(inout self, path: String): # as above

    fn __del__(owned self):
        if self.fd != -1:
            close(self.fd)   # pseudo code, call close(2)
```

è¯·æ³¨æ„â€œçªƒå–ç§»åŠ¨â€æ„é€ å‡½æ•°å¦‚ä½•ä»ç°æœ‰å€¼ä¸­è·å–æ–‡ä»¶æè¿°ç¬¦å¹¶æ”¹å˜è¯¥å€¼ï¼Œä»¥ä¾¿å…¶ææ„å‡½æ•°ä¸ä¼šæ‰§è¡Œä»»ä½•æ“ä½œã€‚è¿™ç§æŠ€æœ¯éœ€è¦æƒè¡¡ï¼Œå¹¶ä¸æ˜¯å¯¹æ¯ç§ç±»å‹éƒ½æ˜¯æœ€å¥½çš„ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å®ƒå‘ææ„å‡½æ•°æ·»åŠ äº†ä¸€ä¸ªï¼ˆå»‰ä»·çš„ï¼‰åˆ†æ”¯ï¼Œå› ä¸ºå®ƒå¿…é¡»æ£€æŸ¥å“¨å…µæƒ…å†µã€‚é€šå¸¸ä¹Ÿè®¤ä¸ºä½¿æ­¤ç±»ç±»å‹å¯ä¸ºç©ºæ˜¯ä¸å¥½çš„å½¢å¼ï¼Œå› ä¸ºåƒç±»å‹è¿™æ ·çš„æ›´é€šç”¨çš„åŠŸèƒ½`Optional[T]`æ˜¯å¤„ç†è¿™ç§æƒ…å†µçš„æ›´å¥½æ–¹æ³•ã€‚

æ­¤å¤–ï¼Œæˆ‘ä»¬è®¡åˆ’åœ¨ Mojo æœ¬èº«ä¸­å®ç°`Optional[T]`ï¼Œå¹¶ä¸”`Optional`éœ€è¦æ­¤åŠŸèƒ½ã€‚æˆ‘ä»¬è¿˜ç›¸ä¿¡ï¼Œåº“ä½œè€…æ¯”è¯­è¨€è®¾è®¡è€…æ›´äº†è§£ä»–ä»¬çš„é¢†åŸŸé—®é¢˜ï¼Œå¹¶ä¸”é€šå¸¸æ›´æ„¿æ„èµ‹äºˆåº“ä½œè€…å¯¹è¯¥é¢†åŸŸçš„å…¨éƒ¨æƒåŠ›ã€‚å› æ­¤ï¼Œæ‚¨å¯ä»¥é€‰æ‹©ï¼ˆä½†ä¸å¿…ï¼‰è®©æ‚¨çš„ç±»å‹ä»¥é€‰æ‹©åŠ å…¥çš„æ–¹å¼å‚ä¸æ­¤è¡Œä¸ºã€‚

### å¯å¤åˆ¶ç±»å‹[](#copyable-types)

å¯ç§»åŠ¨ç±»å‹çš„ä¸‹ä¸€æ­¥æ˜¯å¯å¤åˆ¶ç±»å‹ã€‚å¯å¤åˆ¶ç±»å‹ä¹Ÿå¾ˆå¸¸è§ - ç¨‹åºå‘˜é€šå¸¸æœŸæœ›å­—ç¬¦ä¸²å’Œæ•°ç»„ä¹‹ç±»çš„ä¸œè¥¿æ˜¯å¯å¤åˆ¶çš„ï¼Œå¹¶ä¸”æ¯ä¸ª Python å¯¹è±¡å¼•ç”¨éƒ½æ˜¯å¯å¤åˆ¶çš„ - é€šè¿‡å¤åˆ¶æŒ‡é’ˆå’Œè°ƒæ•´å¼•ç”¨è®¡æ•°ã€‚

æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥å®ç°å¯å¤åˆ¶ç±»å‹ã€‚ä¸€ç§å¯ä»¥å®ç°åƒ Python æˆ– Java è¿™æ ·çš„å¼•ç”¨è¯­ä¹‰ç±»å‹ï¼Œåœ¨å…¶ä¸­ä¼ æ’­å…±äº«æŒ‡é’ˆï¼Œä¸€ç§å¯ä»¥ä½¿ç”¨æ˜“äºå…±äº«çš„ä¸å¯å˜æ•°æ®ç»“æ„ï¼Œå› ä¸ºå®ƒä»¬ä¸€æ—¦åˆ›å»ºå°±ä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼Œä¸€ç§å¯ä»¥é€šè¿‡æƒ°æ€§å†™å…¥æ—¶å¤åˆ¶æ¥å®ç°æ·±å±‚å€¼è¯­ä¹‰å°±åƒæ–¯å¨å¤«ç‰¹é‚£æ ·ã€‚è¿™äº›æ–¹æ³•ä¸­çš„æ¯ä¸€ç§éƒ½æœ‰ä¸åŒçš„æƒè¡¡ï¼ŒMojo è®¤ä¸ºï¼Œè™½ç„¶æˆ‘ä»¬éœ€è¦ä¸€äº›é€šç”¨çš„é›†åˆç±»å‹é›†ï¼Œä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥æ”¯æŒå¹¿æ³›çš„ä¸“æ³¨äºç‰¹å®šç”¨ä¾‹çš„ä¸“ç”¨é›†åˆç±»å‹ã€‚

åœ¨ Mojo ä¸­ï¼Œæ‚¨å¯ä»¥é€šè¿‡å®ç°è¯¥`__copyinit__`æ–¹æ³•æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚è¿™æ˜¯ä½¿ç”¨ç®€å•çš„ç¤ºä¾‹`String`ï¼ˆä¼ªä»£ç ï¼‰ï¼š

```
struct MyString:
    var data: Pointer[UI8]

    # StringRef is a pointer + length and works with StringLiteral.
    def __init__(inout self, input: StringRef):
        self.data = ...

    # Copy the string by deep copying the underlying malloc'd data.
    def __copyinit__(inout self, existing: Self):
        self.data = strdup(existing.data)

    # This isn't required, but optimizes unneeded copies.
    def __moveinit__(inout self, owned existing: Self):
        self.data = existing.data

    def __del__(owned self):
        free(self.data.address)

    def __add__(self, rhs: MyString) -> MyString: ...
```

è¿™ä¸ªç®€å•ç±»å‹æ˜¯ä¸€ä¸ªæŒ‡å‘ç”¨ malloc åˆ†é…çš„â€œç©ºç»ˆæ­¢â€å­—ç¬¦ä¸²æ•°æ®çš„æŒ‡é’ˆï¼Œä¸ºæ¸…æ¥šèµ·è§ï¼Œä½¿ç”¨è€å¼ C APIã€‚å®ƒå®ç°äº†`__copyinit__`ï¼Œå®ƒç»´æŠ¤äº†æ¯ä¸ª å®ä¾‹éƒ½æ‹¥æœ‰å…¶åº•å±‚æŒ‡é’ˆå¹¶åœ¨é”€æ¯æ—¶é‡Šæ”¾å®ƒçš„ä¸å˜å¼`MyString`ã€‚è¿™ä¸ªå®ç°å»ºç«‹åœ¨æˆ‘ä»¬ä¸Šé¢çœ‹åˆ°çš„æŠ€å·§çš„åŸºç¡€ä¸Šï¼Œå¹¶å®ç°äº†ä¸€ä¸ª`__moveinit__`æ„é€ å‡½æ•°ï¼Œè¿™ä½¿å¾—å®ƒå¯ä»¥åœ¨æŸäº›å¸¸è§æƒ…å†µä¸‹å®Œå…¨æ¶ˆé™¤ä¸´æ—¶å‰¯æœ¬ã€‚æ‚¨å¯ä»¥åœ¨æ­¤ä»£ç åºåˆ—ä¸­çœ‹åˆ°æ­¤è¡Œä¸ºï¼š

```
fn test_my_string():
    var s1 = MyString("hello ")

    var s2 = s1    # s2.__copyinit__(s1) runs here

    print(s1)

    var s3 = s1^   # s3.__moveinit__(s1) runs here

    print(s2)
    # s2.__del__() runs here
    print(s3)
    # s3.__del__() runs here
```

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨å¯ä»¥æ˜ç™½ä¸ºä»€ä¹ˆéœ€è¦å¤åˆ¶æ„é€ å‡½æ•°ï¼šå¦‚æœæ²¡æœ‰å¤åˆ¶æ„é€ å‡½æ•°ï¼Œå°†å€¼å¤åˆ¶`s1`åˆ°`s2`å°†æ˜¯ä¸€ä¸ªé”™è¯¯ - å› ä¸ºæ‚¨ä¸èƒ½æ‹¥æœ‰åŒä¸€ä¸å¯å¤åˆ¶ç±»å‹çš„ä¸¤ä¸ªå®æ—¶å®ä¾‹ã€‚ç§»åŠ¨æ„é€ å‡½æ•°æ˜¯å¯é€‰çš„ï¼Œä½†æœ‰åŠ©äºåˆ†é…åˆ°`s3`ï¼šæ²¡æœ‰å®ƒï¼Œç¼–è¯‘å™¨å°†ä» s1 è°ƒç”¨å¤åˆ¶æ„é€ å‡½æ•°ï¼Œç„¶åé”€æ¯æ—§`s1`å®ä¾‹ã€‚è¿™åœ¨é€»è¾‘ä¸Šæ˜¯æ­£ç¡®çš„ï¼Œä½†ä¼šå¸¦æ¥é¢å¤–çš„è¿è¡Œæ—¶å¼€é”€ã€‚

Mojo ä¼šæ€¥åˆ‡åœ°é”€æ¯å€¼ï¼Œè¿™ä½¿å¾—å®ƒèƒ½å¤Ÿå°†å¤åˆ¶+é”€æ¯å¯¹è½¬æ¢ä¸ºå•ä¸ªç§»åŠ¨æ“ä½œï¼Œè¿™å¯ä»¥å¸¦æ¥æ¯” C++ æ›´å¥½çš„æ€§èƒ½ï¼Œè€Œä¸éœ€è¦å¯¹`std::move`.

### çç¢ç±»å‹[](#trivial-types)

æœ€çµæ´»çš„ç±»å‹å°±æ˜¯â€œæ¯”ç‰¹è¢‹â€ã€‚è¿™äº›ç±»å‹æ˜¯â€œå¾®ä¸è¶³é“çš„â€ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥è¢«å¤åˆ¶ã€ç§»åŠ¨å’Œé”€æ¯ï¼Œè€Œæ— éœ€è°ƒç”¨è‡ªå®šä¹‰ä»£ç ã€‚åƒè¿™æ ·çš„ç±»å‹å¯ä»¥è¯´æ˜¯æˆ‘ä»¬å‘¨å›´æœ€å¸¸è§çš„åŸºæœ¬ç±»å‹ï¼šåƒæ•´æ•°å’Œæµ®ç‚¹å€¼è¿™æ ·çš„ä¸œè¥¿éƒ½æ˜¯å¾®ä¸è¶³é“çš„ã€‚ä»è¯­è¨€çš„è§’åº¦æ¥çœ‹ï¼ŒMojo ä¸éœ€è¦å¯¹è¿™äº›è¿›è¡Œç‰¹æ®Šæ”¯æŒï¼Œç±»å‹ä½œè€…å°†è¿™äº›ä¸œè¥¿å®ç°ä¸ºæ— æ“ä½œå¹¶å…è®¸å†…è”å™¨è®©å®ƒä»¬æ¶ˆå¤±æ˜¯å®Œå…¨å¯ä»¥çš„ã€‚

è¿™ç§æ–¹æ³•ä¸æ˜¯æœ€ç†æƒ³çš„æœ‰ä¸¤ä¸ªåŸå› ï¼šä¸€æ˜¯æˆ‘ä»¬ä¸å¸Œæœ›åœ¨ç®€å•ç±»å‹ä¸Šå®šä¹‰ä¸€å †æ–¹æ³•çš„æ ·æ¿ï¼ŒäºŒæ˜¯æˆ‘ä»¬ä¸å¸Œæœ›ç”Ÿæˆå’Œæ¨é€çš„ç¼–è¯‘æ—¶å¼€é”€ä¸€å †å‡½æ•°è°ƒç”¨ï¼Œåªæ˜¯è®©å®ƒä»¬å†…è”åˆ°ä»€ä¹ˆéƒ½æ²¡æœ‰ã€‚æ­¤å¤–ï¼Œè¿˜å­˜åœ¨ä¸€ä¸ªæ­£äº¤é—®é¢˜ï¼Œå³è®¸å¤šç±»å‹åœ¨å¦ä¸€ç§æ„ä¹‰ä¸Šæ˜¯å¾®ä¸è¶³é“çš„ï¼šå®ƒä»¬å¾ˆå°ï¼Œåº”è¯¥åœ¨ CPU çš„å¯„å­˜å™¨ä¸­ä¼ é€’ï¼Œè€Œä¸æ˜¯é—´æ¥åœ¨å†…å­˜ä¸­ä¼ é€’ã€‚

å› æ­¤ï¼ŒMojo æä¾›äº†ä¸€ä¸ªç»“æ„è£…é¥°å™¨æ¥è§£å†³æ‰€æœ‰è¿™äº›é—®é¢˜ã€‚æ‚¨å¯ä»¥ä½¿ç”¨è£…é¥°å™¨å®ç°ç±»å‹`@register_passable("trivial")`ï¼Œè¿™å‘Šè¯‰ Mojo è¯¥ç±»å‹åº”è¯¥æ˜¯å¯å¤åˆ¶å’Œå¯ç§»åŠ¨çš„ï¼Œä½†å®ƒæ²¡æœ‰ç”¨æˆ·å®šä¹‰çš„é€»è¾‘æ¥æ‰§è¡Œæ­¤æ“ä½œã€‚å®ƒè¿˜å‘Šè¯‰ Mojo æ›´å–œæ¬¢ä¼ é€’ CPU å¯„å­˜å™¨ä¸­çš„å€¼ï¼Œè¿™å¯ä»¥å¸¦æ¥æ•ˆç‡ä¼˜åŠ¿ã€‚

TODOï¼šè¿™ä¸ªè£…é¥°å™¨éœ€è¦é‡æ–°è€ƒè™‘ã€‚ç¼ºä¹è‡ªå®šä¹‰é€»è¾‘å¤åˆ¶/ç§»åŠ¨/é”€æ¯é€»è¾‘å’Œâ€œå¯„å­˜å™¨ä¸­çš„å¯ä¼ é€’æ€§â€æ˜¯æ­£äº¤çš„é—®é¢˜ï¼Œåº”è¯¥åˆ†å¼€ã€‚å‰é¢çš„é€»è¾‘åº”è¯¥åŒ…å«åœ¨ä¸€ä¸ªæ›´é€šç”¨çš„`@value("trivial")`è£…é¥°å™¨ä¸­ï¼Œå®ƒä¸ æ­£äº¤`@register_passable`ã€‚

### `@value`è£…é¥°è€…[](#value-decorator)

Mojo çš„[ä»·å€¼ç”Ÿå‘½å‘¨æœŸ](https://docs.modular.com/mojo/programming-manual.html#value-lifecycle-birth-life-and-death-of-a-value)æä¾›äº†ç®€å•ä¸”å¯é¢„æµ‹çš„é’©å­ï¼Œä½¿æ‚¨èƒ½å¤Ÿæ­£ç¡®è¡¨è¾¾å¼‚å›½æƒ…è°ƒçš„ä½çº§äº‹ç‰©`Atomic`ã€‚è¿™å¯¹äºæ§åˆ¶å’Œç®€å•çš„ç¼–ç¨‹æ¨¡å‹æ¥è¯´éå¸¸æœ‰ç”¨ï¼Œä½†å¤§å¤šæ•°ç»“æ„éƒ½æ˜¯å…¶ä»–ç±»å‹çš„ç®€å•èšåˆï¼Œæˆ‘ä»¬ä¸æƒ³ä¸ºå®ƒä»¬ç¼–å†™å¤§é‡æ ·æ¿æ–‡ä»¶ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒMojo æä¾›äº†ä¸€ä¸ª`@value`ç»“æ„è£…é¥°å™¨ï¼Œå¯ä»¥ä¸ºæ‚¨åˆæˆå¤§é‡æ ·æ¿æ–‡ä»¶ã€‚

æ‚¨å¯ä»¥å°†`@value`å…¶è§†ä¸º Python çš„æ‰©å±•[`@dataclass`](https://docs.python.org/3/library/dataclasses.html)ï¼Œå®ƒè¿˜å¯ä»¥å¤„ç† Mojo`__moveinit__`å’Œ`__copyinit__`æ–¹æ³•ã€‚

è£…é¥°`@value`å™¨ä¼šæŸ¥çœ‹æ‚¨ç±»å‹çš„å­—æ®µï¼Œå¹¶ç”Ÿæˆä¸€äº›ç¼ºå°‘çš„æˆå‘˜ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘è¿™æ ·ä¸€ä¸ªç®€å•çš„ç»“æ„ï¼š

```
@value
struct MyPet:
    var name: String
    var age: Int
```

Mojo ä¼šæ³¨æ„åˆ°æ‚¨æ²¡æœ‰æˆå‘˜åˆå§‹åŒ–å™¨ã€ç§»åŠ¨æ„é€ å‡½æ•°æˆ–å¤åˆ¶æ„é€ å‡½æ•°ï¼Œå®ƒä¼šä¸ºæ‚¨åˆæˆè¿™äº›ï¼Œå°±åƒæ‚¨ç¼–å†™çš„ä¸€æ ·ï¼š

```
struct MyPet:
    var name: String
    var age: Int

    fn __init__(inout self, owned name: String, age: Int):
        self.name = name^
        self.age = age

    fn __copyinit__(inout self, existing: Self):
        self.name = existing.name
        self.age = existing.age

    fn __moveinit__(inout self, owned existing: Self):
        self.name = existing.name^
        self.age = existing.age
```

å½“æ‚¨æ·»åŠ `@value`è£…é¥°å™¨æ—¶ï¼ŒMojo ä»…å½“è¿™äº›ç‰¹æ®Šæ–¹æ³•ä¸å­˜åœ¨æ—¶æ‰ä¼šåˆæˆå®ƒä»¬ã€‚æ‚¨å¯ä»¥é€šè¿‡å®šä¹‰è‡ªå·±çš„ç‰ˆæœ¬æ¥è¦†ç›–ä¸€ä¸ªæˆ–å¤šä¸ªç‰ˆæœ¬çš„è¡Œä¸ºã€‚ä¾‹å¦‚ï¼Œæƒ³è¦è‡ªå®šä¹‰å¤åˆ¶æ„é€ å‡½æ•°ä½†ä½¿ç”¨é»˜è®¤çš„æˆå‘˜æ–¹å¼å’Œç§»åŠ¨æ„é€ å‡½æ•°æ˜¯ç›¸å½“å¸¸è§çš„ã€‚

ç”±äºç»“æ„å–å¾—æ‰€æœ‰æƒå¹¶å­˜å‚¨å€¼ï¼Œå› æ­¤ çš„å‚æ•°`__init__`å…¨éƒ¨ä½œä¸ºå‚æ•°ä¼ é€’ã€‚`owned`è¿™æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„å¾®è§‚ä¼˜åŒ–ï¼Œå¯ä»¥ä½¿ç”¨ä»…ç§»åŠ¨ç±»å‹ã€‚åƒè¿™æ ·çš„ç®€å•ç±»å‹`Int`ä¹Ÿå¯ä»¥ä½œä¸ºè‡ªæœ‰å€¼ä¼ é€’ï¼Œä½†ç”±äºè¿™å¯¹å®ƒä»¬æ¥è¯´æ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼Œå› æ­¤`^`ä¸ºäº†æ¸…æ¥šèµ·è§ï¼Œæˆ‘ä»¬çœç•¥äº†æ ‡è®°å’Œä¼ è¾“è¿ç®—ç¬¦ ( )ã€‚

**æ³¨æ„ï¼š**å¦‚æœæ‚¨çš„ç±»å‹åŒ…å«ä»»ä½•[ä»…ç§»åŠ¨](https://docs.modular.com/mojo/programming-manual.html#unique-move-only-types)å­—æ®µï¼ŒMojo å°†ä¸ä¼šç”Ÿæˆå¤åˆ¶æ„é€ å‡½æ•°ï¼Œå› ä¸ºå®ƒæ— æ³•å¤åˆ¶è¿™äº›å­—æ®µã€‚æ­¤å¤–ï¼Œ`@value`è£…é¥°å™¨ä»…é€‚ç”¨äºå…¶æˆå‘˜å¯å¤åˆ¶å’Œ/æˆ–å¯ç§»åŠ¨çš„ç±»å‹ã€‚å¦‚æœæ‚¨`Atomic`çš„ç»“æ„ä¸­æœ‰ç±»ä¼¼çš„å†…å®¹ï¼Œé‚£ä¹ˆå®ƒå¯èƒ½ä¸æ˜¯å€¼ç±»å‹ï¼Œå¹¶ä¸”æ‚¨æ— è®ºå¦‚ä½•éƒ½ä¸æƒ³è¦è¿™äº›æˆå‘˜ã€‚

å¦è¯·æ³¨æ„ï¼Œ`MyPet`ä¸Šé¢çš„ç»“æ„ä¸åŒ…æ‹¬`__del__()`ææ„å‡½æ•° - Mojo ä¹Ÿç»¼åˆäº†å®ƒï¼Œä½†å®ƒä¸éœ€è¦è£…é¥°å™¨ï¼ˆè¯·å‚é˜…ä¸‹é¢æœ‰å…³[ææ„å‡½æ•°](https://docs.modular.com/mojo/programming-manual.html#behavior-of-destructors)`@value`çš„éƒ¨åˆ†ï¼‰ã€‚[](https://docs.modular.com/mojo/programming-manual.html#behavior-of-destructors)

æ­¤æ—¶æ²¡æœ‰åŠæ³•æŠ‘åˆ¶ç‰¹å®šæ–¹æ³•çš„ç”Ÿæˆæˆ–è‡ªå®šä¹‰ç”Ÿæˆï¼Œä½†`@value`å¦‚æœæœ‰éœ€æ±‚ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç”Ÿæˆå™¨æ·»åŠ å‚æ•°æ¥æ‰§è¡Œæ­¤æ“ä½œã€‚

## ææ„å‡½æ•°çš„è¡Œä¸º[](#behavior-of-destructors)

Mojo ä¸­çš„ä»»ä½•ç»“æ„éƒ½å¯ä»¥æœ‰ä¸€ä¸ªææ„å‡½æ•°ï¼ˆä¸€ç§`__del__()`æ–¹æ³•ï¼‰ï¼Œè¯¥ææ„å‡½æ•°ä¼šåœ¨å€¼çš„ç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶ï¼ˆé€šå¸¸æ˜¯æœ€åä½¿ç”¨è¯¥å€¼çš„æ—¶é—´ç‚¹ï¼‰è‡ªåŠ¨è¿è¡Œã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªç®€å•çš„å­—ç¬¦ä¸²å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼ˆä¼ªä»£ç ï¼‰ï¼š

```
@value
struct MyString:
    var data: Pointer[UInt8]

    def __init__(inout self, input: StringRef): ...
    def __add__(self, rhs: String) -> MyString: ...
    def __del__(owned self):
        free(self.data.address)
```

Mojoä½¿ç”¨æ¯æ¬¡è°ƒç”¨åè¿è¡Œçš„**â€œå°½å¿«â€**`MyString` (ASAP) ç­–ç•¥æ¥é”€æ¯è¯¸å¦‚ï¼ˆå®ƒè°ƒç”¨ææ„å‡½æ•°ï¼‰ä¹‹ç±»çš„å€¼ã€‚Mojo ä¸ä¼š_ç­‰åˆ°_ä»£ç å—ç»“æŸæ—¶æ‰é”€æ¯æœªä½¿ç”¨çš„å€¼ã€‚å³ä½¿åœ¨åƒè¿™æ ·çš„è¡¨è¾¾å¼ä¸­ï¼Œä¸€æ—¦ä¸å†éœ€è¦ä¸­é—´è¡¨è¾¾å¼ï¼ŒMojo å°±ä¼šç«‹å³é”€æ¯å®ƒä»¬ï¼Œè€Œä¸ä¼šç­‰åˆ°è¯­å¥ç»“æŸã€‚`__del__()`****__`a+b+c+d`

å½“å€¼å¤±æ•ˆæ—¶ï¼ŒMojo ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°ï¼Œå¹¶ä¸ºææ„å‡½æ•°ä½•æ—¶è¿è¡Œæä¾›å¼ºæœ‰åŠ›çš„ä¿è¯ã€‚Mojo ä½¿ç”¨é™æ€ç¼–è¯‘å™¨åˆ†ææ¥æ¨ç†ä»£ç å¹¶å†³å®šä½•æ—¶æ’å…¥å¯¹ææ„å‡½æ•°çš„è°ƒç”¨ã€‚ä¾‹å¦‚ï¼š

```
fn use_strings():
    var a = String("hello a")
    let b = String("hello b")
    print(a)
    # a.__del__() runs here for "hello a"


    print(b)
    # b.__del__() runs here

    a = String("temporary a")
    # a.__del__() runs here because "temporary a" is never used

    # Other stuff happens here

    a = String("final a")
    print(a)
    # a.__del__() runs again here for "final a"

use_strings()
```

```
hello a
hello b
final a
```

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæ‚¨å°†çœ‹åˆ° å’Œ`a`å€¼`b`æ˜¯åœ¨æ—©æœŸåˆ›å»ºçš„ï¼Œå¹¶ä¸”å€¼çš„æ¯ä¸ªåˆå§‹åŒ–éƒ½ä¸å¯¹ææ„å‡½æ•°çš„è°ƒç”¨ç›¸åŒ¹é…ã€‚è¯·æ³¨æ„ï¼Œå®ƒ`a`ä¼šè¢«å¤šæ¬¡é”€æ¯â€”â€”æ¯æ¬¡æ”¶åˆ°æ–°å€¼æ—¶éƒ½ä¼šè¢«é”€æ¯ä¸€æ¬¡ã€‚

ç°åœ¨ï¼Œè¿™å¯èƒ½ä¼šè®© C++ ç¨‹åºå‘˜æ„Ÿåˆ°æƒŠè®¶ï¼Œå› ä¸ºå®ƒä¸[RAII æ¨¡å¼ä¸åŒï¼Œåœ¨ RAII æ¨¡å¼](https://en.cppreference.com/w/cpp/language/raii)ä¸­ï¼ŒC++ åœ¨ä½œç”¨åŸŸæœ«å°¾é”€æ¯å€¼ã€‚Mojo è¿˜éµå¾ªè¿™æ ·çš„åŸåˆ™ï¼šå€¼åœ¨æ„é€ å‡½æ•°ä¸­è·å–èµ„æºå¹¶åœ¨ææ„å‡½æ•°ä¸­é‡Šæ”¾èµ„æºï¼Œä½† Mojo ä¸­çš„æ€¥åˆ‡é”€æ¯æ¯” C++ ä¸­åŸºäºèŒƒå›´çš„é”€æ¯å…·æœ‰è®¸å¤šå¼ºå¤§çš„ä¼˜åŠ¿ï¼š

* Mojo æ–¹æ³•æ¶ˆé™¤äº†ç±»å‹å®ç°é‡æ–°èµ‹å€¼è¿ç®—ç¬¦çš„éœ€è¦ï¼Œä¾‹å¦‚C++ ä¸­çš„`operator=(const T&)`and `operator=(T&&)`ï¼Œä»è€Œæ›´å®¹æ˜“å®šä¹‰ç±»å‹å¹¶æ¶ˆé™¤æ¦‚å¿µã€‚
* Mojo ä¸å…è®¸å¯å˜å¼•ç”¨ä¸å…¶ä»–å¯å˜å¼•ç”¨æˆ–ä¸å¯å˜å€Ÿç”¨é‡å ã€‚å®ƒæä¾›å¯é¢„æµ‹ç¼–ç¨‹æ¨¡å‹çš„ä¸€ä¸ªä¸»è¦æ–¹æ³•æ˜¯ç¡®ä¿å¯¹å¯¹è±¡çš„å¼•ç”¨å°½å¿«æ¶ˆå¤±ï¼Œé¿å…ç¼–è¯‘å™¨è®¤ä¸ºä¸€ä¸ªå€¼å¯èƒ½ä»ç„¶å­˜åœ¨å¹¶å¹²æ‰°å¦ä¸€ä¸ªå€¼çš„æ··ä¹±æƒ…å†µï¼Œä½†è¿™å¯¹äºç”¨æˆ·ã€‚
* åœ¨æœ€åä½¿ç”¨æ—¶é”€æ¯å€¼ä¸â€œç§»åŠ¨â€ä¼˜åŒ–å¾ˆå¥½åœ°ç»“åˆåœ¨ä¸€èµ·ï¼Œå®ƒå°†â€œå¤åˆ¶+åˆ é™¤â€å¯¹è½¬æ¢ä¸ºâ€œç§»åŠ¨â€æ“ä½œï¼Œè¿™æ˜¯ C++ ç§»åŠ¨ä¼˜åŒ–çš„æ¨å¹¿ï¼Œå¦‚ NRVOï¼ˆç§°ä¸ºè¿”å›å€¼ä¼˜åŒ–ï¼‰ã€‚
* å¯¹äºæŸäº›å¸¸è§æ¨¡å¼ï¼ˆä¾‹å¦‚å°¾é€’å½’ï¼‰ï¼Œåœ¨ C++ ä¸­é”€æ¯ä½œç”¨åŸŸæœ«å°¾çš„å€¼æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºææ„å‡½æ•°è°ƒç”¨å‘ç”Ÿåœ¨å°¾è°ƒç”¨ä¹‹åã€‚å¯¹äºæŸäº›å‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼æ¥è¯´ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªé‡å¤§çš„æ€§èƒ½å’Œå†…å­˜é—®é¢˜ã€‚

é‡è¦çš„æ˜¯ï¼ŒMojo çš„çƒ­åˆ‡é”€æ¯åœ¨ Python é£æ ¼çš„`def`å‡½æ•°ä¸­ä¹Ÿèƒ½å¾ˆå¥½åœ°å·¥ä½œï¼Œä»¥åœ¨ç»†ç²’åº¦çº§åˆ«æä¾›é”€æ¯ä¿è¯ï¼ˆæ— éœ€åƒåœ¾æ”¶é›†å™¨ï¼‰â€”â€”å›æƒ³ä¸€ä¸‹ï¼ŒPython å¹¶ä¸çœŸæ­£æä¾›è¶…å‡ºå‡½æ•°çš„ä½œç”¨åŸŸï¼Œå› æ­¤ Mojo ä¸­çš„ C++ é£æ ¼é”€æ¯ä¼šå°‘å¾ˆå¤šç”¨å¤„ã€‚

**æ³¨æ„ï¼š** Mojo è¿˜æ”¯æŒ Python é£æ ¼çš„[`with`è¯­å¥](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement)ï¼Œå®ƒæä¾›äº†å¯¹èµ„æºæ›´æœ‰æ„èŒƒå›´çš„è®¿é—®ã€‚

Mojo æ–¹æ³•ä¸ Rust å’Œ Swift çš„å·¥ä½œæ–¹å¼æ›´ç›¸ä¼¼ï¼Œå› ä¸ºå®ƒä»¬éƒ½å…·æœ‰å¼ºå¤§çš„ä»·å€¼æ‰€æœ‰æƒè·Ÿè¸ªå¹¶æä¾›å†…å­˜å®‰å…¨ã€‚ä¸€ä¸ªåŒºåˆ«æ˜¯å®ƒä»¬çš„å®ç°éœ€è¦ä½¿ç”¨[åŠ¨æ€â€œæ”¾ç½®æ ‡å¿—â€](https://doc.rust-lang.org/nomicon/drop-flags.html) â€”â€”å®ƒä»¬ç»´æŠ¤éšè—çš„å½±å­å˜é‡æ¥è·Ÿè¸ªå€¼çš„çŠ¶æ€ä»¥æä¾›å®‰å…¨æ€§ã€‚è¿™äº›é€šå¸¸ä¼šè¢«ä¼˜åŒ–æ‰ï¼Œä½† Mojo æ–¹æ³•å®Œå…¨æ¶ˆé™¤äº†è¿™ç§å¼€é”€ï¼Œä½¿ç”Ÿæˆçš„ä»£ç æ›´å¿«å¹¶é¿å…æ­§ä¹‰ã€‚

### ç°åœºæ•æ„Ÿçš„ç”Ÿå‘½å‘¨æœŸç®¡ç†[](#field-sensitive-lifetime-management)

Mojo çš„ç”Ÿå‘½å‘¨æœŸåˆ†æé™¤äº†å®Œå…¨æ§åˆ¶æµæ„ŸçŸ¥ä¹‹å¤–ï¼Œå®ƒè¿˜å®Œå…¨å­—æ®µæ•æ„Ÿï¼ˆç»“æ„çš„æ¯ä¸ªå­—æ®µéƒ½æ˜¯ç‹¬ç«‹è·Ÿè¸ªçš„ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒMojo å•ç‹¬è·Ÿè¸ªâ€œæ•´ä¸ªå¯¹è±¡â€æ˜¯å®Œå…¨è¿˜æ˜¯ä»…éƒ¨åˆ†åˆå§‹åŒ–/é”€æ¯ã€‚

ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹ä»£ç ï¼š

```
@value
struct TwoStrings:
    var str1: String
    var str2: String

fn use_two_strings():
    var ts = TwoStrings("foo", "bar")
    print(ts.str1)
    # ts.str1.__del__() runs here

    # Other stuff happens here

    ts.str1 = String("hello") # Overwrite ts.str1
    print(ts.str1)
    # ts.__del__() runs here

use_two_strings()
```

```
foo
hello
```

è¯·æ³¨æ„ï¼Œè¯¥`ts.str1`å­—æ®µå‡ ä¹ç«‹å³è¢«é”€æ¯ï¼Œå› ä¸º Mojo çŸ¥é“å®ƒå°†è¢«ä¸‹é¢è¦†ç›–ã€‚[æ‚¨è¿˜å¯ä»¥åœ¨ä½¿ç”¨è½¬ç§»è¿ç®—ç¬¦](https://docs.modular.com/mojo/programming-manual.html#owned-arguments)æ—¶çœ‹åˆ°è¿™ä¸€ç‚¹ï¼Œä¾‹å¦‚ï¼š

```
fn consume(owned arg: String):
    pass

fn use(arg: TwoStrings):
    print(arg.str1)

fn consume_and_use_two_strings():
    var ts = TwoStrings("foo", "bar")
    consume(ts.str1^)
    # ts.str1.__moveinit__() runs here

    # ts is now only partially initialized here!

    ts.str1 = String("hello")  # All together now
    use(ts)                    # This is ok
    # ts.__del__() runs here

consume_and_use_two_strings()
```

```
hello
```

è¯·æ³¨æ„ï¼Œä»£ç è½¬ç§»äº†è¯¥`str1`å­—æ®µçš„æ‰€æœ‰æƒï¼šåœ¨ çš„æŒç»­æ—¶é—´å†…`other_stuff()`ï¼Œè¯¥`str1`å­—æ®µå®Œå…¨æœªåˆå§‹åŒ–ï¼Œå› ä¸ºæ‰€æœ‰æƒå·²è½¬ç§»åˆ°`consume()`ã€‚ç„¶å`str1`åœ¨è¢«`use()`å‡½æ•°ä½¿ç”¨ä¹‹å‰é‡æ–°åˆå§‹åŒ–ï¼ˆå¦‚æœä¸æ˜¯ï¼ŒMojo ä¼šæ‹’ç»ä»£ç å¹¶æ˜¾ç¤ºæœªåˆå§‹åŒ–å­—æ®µé”™è¯¯ï¼‰ã€‚

Mojo å¯¹æ­¤çš„è§„åˆ™éå¸¸å¼ºå¤§ä¸”æœ‰æ„ç›´æ¥ï¼šå­—æ®µå¯ä»¥ä¸´æ—¶è½¬ç§»ï¼Œä½†â€œæ•´ä¸ªå¯¹è±¡â€å¿…é¡»ä½¿ç”¨èšåˆç±»å‹çš„åˆå§‹å€¼è®¾å®šé¡¹æ„é€ å¹¶ä½¿ç”¨èšåˆææ„å‡½æ•°é”€æ¯ã€‚è¿™æ„å‘³ç€ä¸å¯èƒ½é€šè¿‡ä»…åˆå§‹åŒ–å…¶å­—æ®µæ¥åˆ›å»ºå¯¹è±¡ï¼Œä¹Ÿä¸å¯èƒ½é€šè¿‡ä»…é”€æ¯å…¶å­—æ®µæ¥æ‹†é™¤å¯¹è±¡ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç æ— æ³•ç¼–è¯‘ï¼š

```
fn consume_and_use_two_strings():
    let ts = TwoStrings("foo", "bar") # ts is initialized
    # Uncomment to see an error:
    # consume(ts.str1^)
    # Because `ts` is not used anymore, it should be destroyed here, but
    # the object is not whole, preventing the overall value from being destroyed

    let ts2 : TwoStrings # ts2 type is declared but not initialized
    ts2.str1 = String("foo")
    ts2.str2 = String("bar")  # Both the member are initalized
    # Uncomment to see an error:
    # use(ts2) # Error: 'ts2' isn't fully initialized
```

è™½ç„¶æˆ‘ä»¬å¯ä»¥å…è®¸è¿™æ ·çš„æ¨¡å¼å‘ç”Ÿï¼Œä½†æˆ‘ä»¬æ‹’ç»è¿™ç§æƒ…å†µï¼Œå› ä¸ºå€¼ä¸ä»…ä»…æ˜¯å…¶å„éƒ¨åˆ†çš„æ€»å’Œã€‚è€ƒè™‘åŒ…å« POSIX æ–‡ä»¶æè¿°ç¬¦ä½œä¸ºæ•´æ•°å€¼çš„ a `FileDescriptor`ï¼šé”€æ¯æ•´æ•°ï¼ˆæ— æ“ä½œï¼‰å’Œé”€æ¯`FileDescriptor`ï¼ˆå¯èƒ½è°ƒç”¨`close()`ç³»ç»Ÿè°ƒç”¨ï¼‰ä¹‹é—´å­˜åœ¨å¾ˆå¤§å·®å¼‚ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¦æ±‚æ‰€æœ‰å…¨å€¼åˆå§‹åŒ–éƒ½ç»è¿‡åˆå§‹å€¼è®¾å®šé¡¹å¹¶ç”¨å…¶å…¨å€¼ææ„å‡½æ•°é”€æ¯ã€‚

å°±å…¶ä»·å€¼è€Œè¨€ï¼ŒMojo å†…éƒ¨ç¡®å®å…·æœ‰ä¸ Rust å‡½æ•°ç­‰æ•ˆçš„[`mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget.html)åŠŸèƒ½ï¼Œå®ƒæ˜¾å¼ç¦ç”¨ææ„å‡½æ•°ï¼Œå¹¶å…·æœ‰ç”¨äºâ€œç¥ç¦â€å¯¹è±¡çš„ç›¸åº”å†…éƒ¨åŠŸèƒ½ï¼Œä½†æ­¤æ—¶å®ƒä»¬å°šæœªå…¬å¼€ä¾›ç”¨æˆ·ä½¿ç”¨ã€‚

### ç°åœºå¯¿å‘½`__init__`[](#field-lifetimes-in-__init__)

æ–¹æ³•çš„è¡Œä¸º`__init__`å‡ ä¹ä¸ä»»ä½•å…¶ä»–æ–¹æ³•ä¸€æ · - æœ‰ä¸€ç‚¹ç¥å¥‡ï¼šå®ƒçŸ¥é“å¯¹è±¡çš„å­—æ®µæœªåˆå§‹åŒ–ï¼Œä½†å®ƒç›¸ä¿¡æ•´ä¸ªå¯¹è±¡å·²åˆå§‹åŒ–ã€‚è¿™æ„å‘³ç€`self`ä¸€æ—¦æ‰€æœ‰å­—æ®µéƒ½åˆå§‹åŒ–ï¼Œæ‚¨å°±å¯ä»¥å°†å…¶ç”¨ä½œæ•´ä¸ªå¯¹è±¡ï¼š

```
fn use(arg: TwoStrings2):
    pass

struct TwoStrings2:
    var str1: String
    var str2: String

    fn __init__(inout self, cond: Bool, other: String):
        self.str1 = String()
        if cond:
            self.str2 = other
            use(self)  # Safe to use immediately!
            # self.str2.__del__(): destroyed because overwritten below.

        self.str2 = self.str1
        use(self)  # Safe to use immediately!
```

ç±»ä¼¼åœ°ï¼ŒMojo ä¸­çš„åˆå§‹åŒ–å™¨å®Œå…¨è¦†ç›– æ˜¯å®‰å…¨çš„`self`ï¼Œä¾‹å¦‚é€šè¿‡å§”æ‰˜ç»™å…¶ä»–åˆå§‹åŒ–å™¨ï¼š

```
struct TwoStrings3:
    var str1: String
    var str2: String

    fn __init__(inout self):
        self.str1 = String()
        self.str2 = String()

    fn __init__(inout self, one: String):
        self = TwoStrings3()  # Delegate to the basic init
        self.str1 = one
```

### å’Œ`owned`ä¸­å‚æ•°çš„å­—æ®µç”Ÿå‘½å‘¨æœŸ`__moveinit__``__del__`[](#field-lifetimes-of-owned-arguments-in-__moveinit__-and-__del__)

ç§»åŠ¨åˆå§‹å€¼è®¾å®šé¡¹å’Œææ„`owned`å‡½æ•°çš„å‚æ•°å­˜åœ¨æœ€åä¸€ç‚¹é­”åŠ›ã€‚å›é¡¾ä¸€ä¸‹ï¼Œè¿™äº›æ–¹æ³•ç­¾åå¦‚ä¸‹æ‰€ç¤ºï¼š`__moveinit__()``__del__()`

```
struct TwoStrings:
    ...
    fn __moveinit__(inout self, owned existing: Self):
        # Initializes a new `self` by consuming the contents of `existing`
    fn __del__(owned self):
        # Destroys all resources in `self`
```

è¿™äº›æ–¹æ³•é¢ä¸´ä¸€ä¸ªæœ‰è¶£ä½†æ™¦æ¶©éš¾æ‡‚çš„é—®é¢˜ï¼šè¿™ä¸¤ç§æ–¹æ³•éƒ½è´Ÿè´£æ‹†è§£`owned` `existing`/`self`å€¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ`__moveinit__()`é”€æ¯ çš„å­å…ƒç´ `existing`ä»¥ä¾¿å°†æ‰€æœ‰æƒè½¬ç§»åˆ°æ–°å®ä¾‹ï¼ŒåŒæ—¶`__del__()`å®ç°å…¶ çš„åˆ é™¤é€»è¾‘`self`ã€‚å› æ­¤ï¼Œä»–ä»¬éƒ½å¸Œæœ›æ‹¥æœ‰å¹¶è½¬æ¢è¯¥`owned`å€¼çš„å…ƒç´ ï¼Œå¹¶ä¸”ä»–ä»¬ç»å¯¹ä¸å¸Œæœ›è¯¥`owned`å€¼çš„ææ„å‡½æ•°ä¹Ÿè¿è¡Œï¼ˆåœ¨è¯¥æ–¹æ³•çš„æƒ…å†µä¸‹`__del__()`ï¼Œè¿™å°†å˜æˆæ— é™å¾ªç¯ï¼‰ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒMojo ä¸“é—¨å¤„ç†è¿™ä¸¤ä¸ªæ–¹æ³•ï¼Œå‡è®¾å®ƒä»¬çš„æ•´ä¸ªå€¼åœ¨ä»æ–¹æ³•è¿”å›æ—¶è¢«é”€æ¯ã€‚è¿™æ„å‘³ç€åœ¨ä¼ è¾“å­—æ®µå€¼ä¹‹å‰å¯ä»¥ä½¿ç”¨æ•´ä¸ªå¯¹è±¡ã€‚ä¾‹å¦‚ï¼Œè¿™å°†æŒ‰æ‚¨çš„é¢„æœŸå·¥ä½œï¼š

```
fn consume(owned str: String):
    print('Consumed', str)

struct TwoStrings4:
    var str1: String
    var str2: String

    fn __init__(inout self, one: String):
        self.str1 = one
        self.str2 = String("bar")

    fn __moveinit__(inout self, owned existing: Self):
        self.str1 = existing.str1
        self.str2 = existing.str2

    fn __del__(owned self):
        self.dump() # Self is still whole here
        # Mojo calls self.str2.__del__() since str2 isn't used anymore

        consume(self.str1^)
        # str1 has now been transferred;
        # `self.__del__()` is not called (avoiding an infinite loop).
    
    fn dump(inout self):
        print('str1:', self.str1)
        print('str2:', self.str2)

fn use_two_strings():
    let two_strings = TwoStrings4("foo")

# We use a function call to ensure the `two_strings` ownership is enforced
# (Currently, ownership is not enforced for top-level code in notebooks)
use_two_strings()
```

```
str1: foo
str2: bar
Consumed foo
```

æ‚¨é€šå¸¸ä¸å¿…è€ƒè™‘è¿™ä¸€ç‚¹ï¼Œä½†å¦‚æœæ‚¨çš„é€»è¾‘å…·æœ‰æŒ‡å‘æˆå‘˜çš„å†…éƒ¨æŒ‡é’ˆï¼Œåˆ™å¯èƒ½éœ€è¦ä½¿å®ƒä»¬åœ¨ææ„å‡½æ•°æˆ–ç§»åŠ¨åˆå§‹å€¼è®¾å®šé¡¹æœ¬èº«ä¸­çš„æŸäº›é€»è¾‘ä¸­ä¿æŒæ´»åŠ¨çŠ¶æ€ã€‚æ‚¨å¯ä»¥é€šè¿‡åˆ†é…`_`â€œdiscardâ€æ¨¡å¼æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼š

```
fn __del__(owned self):
    self.dump() # Self is still whole here

    consume(self.str1^)
    _ = self.str2
    # self.str2.__del__(): Mojo destroys str2 after its last use.
```

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœä»¥æŸç§æ–¹å¼`consume()`éšå¼å¼•ç”¨æŸä¸ªå€¼`str2`ï¼Œè¿™å°†ç¡®ä¿`str2`ç›´åˆ°æœ€åä¸€æ¬¡ä½¿ç”¨ä¸¢å¼ƒæ¨¡å¼è®¿é—®å®ƒæ—¶æ‰è¢«é”€æ¯`_`ã€‚

### å®šä¹‰æ`__del__`æ„å‡½æ•°[](#defining-the-__del__-destructor)

æ‚¨åº”è¯¥å®šä¹‰`__del__()`æ–¹æ³•æ¥æ‰§è¡Œç±»å‹æ‰€éœ€çš„ä»»ä½•ç±»å‹çš„æ¸…ç†ã€‚é€šå¸¸ï¼Œè¿™åŒ…æ‹¬é‡Šæ”¾ä»»ä½•ä¸å¹³å‡¡æˆ–ä¸å¯ç ´åçš„å­—æ®µçš„å†…å­˜ - ä¸€æ—¦ä¸å†ä½¿ç”¨ä»»ä½•å¹³å‡¡å’Œå¯ç ´åçš„ç±»å‹ï¼ŒMojo å°±ä¼šè‡ªåŠ¨é”€æ¯å®ƒä»¬ã€‚

ä¾‹å¦‚ï¼Œè€ƒè™‘è¿™ä¸ªç»“æ„ï¼š

```
struct MyPet:
    var name: String
    var age: Int

    fn __init__(inout self, owned name: String, age: Int):
        self.name = name^
        self.age = age
```

ä¸éœ€è¦å®šä¹‰è¯¥`__del__()`æ–¹æ³•ï¼Œå› ä¸º`String`å®ƒæ˜¯å¯ç ´åçš„ï¼ˆå®ƒæœ‰è‡ªå·±çš„`__del__()`æ–¹æ³•ï¼‰ï¼Œä¸€æ—¦ä¸å†ä½¿ç”¨ï¼ˆå³`MyPet`ä¸å†ä½¿ç”¨å®ä¾‹æ—¶ï¼‰ï¼ŒMojo å°±ä¼šé”€æ¯å®ƒï¼Œå¹¶ä¸”`Int`æ˜¯ä¸€ä¸ª[æ™®é€šç±»å‹](https://docs.modular.com/mojo/programming-manual.html#trivial-types)ï¼ŒMojo ä¼šå›æ”¶è¿™ä¸ªè®°å¿†ä¹Ÿå°½å¿«ï¼ˆè™½ç„¶æœ‰ç‚¹ä¸åŒï¼Œè€Œä¸éœ€è¦ä¸€ä¸ª`__del__()`æ–¹æ³•ï¼‰ã€‚

ç„¶è€Œï¼Œä»¥ä¸‹ç»“æ„å¿…é¡»å®šä¹‰`__del__()`é‡Šæ”¾ä¸ºå…¶åˆ†é…çš„å†…å­˜çš„æ–¹æ³•`Pointer`ï¼š

```
struct Array[Type: AnyType]:
    var data: Pointer[Type]
    var size: Int

    fn __init__(inout self, size: Int, value: Type):
        self.size = size
        self.data = Pointer[Type].alloc(self.size)
        for i in range(self.size):
            self.data.store(i, value)
            
    fn __del__(owned self):
        self.data.free()
```

## ç”Ÿå‘½å‘¨æœŸ[](#lifetimes)

TODOï¼šè§£é‡Šè¿”å›å¼•ç”¨å¦‚ä½•å·¥ä½œï¼Œä¸ä¸å‚æ•°ç›¸å»åˆçš„ç”Ÿå‘½å‘¨æœŸç›¸å…³è”ã€‚è¯¥åŠŸèƒ½å°šæœªå¯ç”¨ã€‚

## ç±»å‹ç‰¹å¾[](#type-traits)

è¿™æ˜¯ä¸€ä¸ªéå¸¸ç±»ä¼¼äº Rust ç‰¹å¾æˆ– Swift åè®®æˆ– Haskell ç±»å‹ç±»çš„åŠŸèƒ½ã€‚è¯·æ³¨æ„ï¼Œè¿™å°šæœªå®æ–½ã€‚

## é«˜çº§/æ™¦æ¶©çš„ Mojo åŠŸèƒ½[](#advancedobscure-mojo-features)

æœ¬èŠ‚ä»‹ç»å¯¹äºæ„å»ºæ ‡å‡†åº“æœ€åº•å±‚éå¸¸é‡è¦çš„é«˜çº§ç”¨æˆ·åŠŸèƒ½ã€‚è¿™ä¸€çº§åˆ«çš„å †æ ˆåŒ…å«ä¸€äº›ç‹­çª„çš„åŠŸèƒ½ï¼Œéœ€è¦å…·å¤‡ç¼–è¯‘å™¨å†…éƒ¨çš„ç»éªŒæ‰èƒ½æœ‰æ•ˆåœ°ç†è§£å’Œåˆ©ç”¨ã€‚

### `@register_passable`ç»“æ„è£…é¥°å™¨[](#register_passable-struct-decorator)

å¤„ç†å€¼çš„é»˜è®¤æ¨¡å‹æ˜¯å®ƒä»¬å­˜åœ¨äºå†…å­˜ä¸­ï¼Œå› æ­¤å®ƒä»¬å…·æœ‰æ ‡è¯†ï¼Œè¿™æ„å‘³ç€å®ƒä»¬é—´æ¥åœ°ä¼ å…¥å’Œä¼ å‡ºå‡½æ•°ï¼ˆç­‰æ•ˆåœ°ï¼Œå®ƒä»¬åœ¨æœºå™¨çº§åˆ«â€œé€šè¿‡å¼•ç”¨â€ä¼ é€’ï¼‰ã€‚è¿™å¯¹äºæ— æ³•ç§»åŠ¨çš„ç±»å‹éå¸¸æœ‰ç”¨ï¼Œå¹¶ä¸”å¯¹äºå¤§å‹å¯¹è±¡æˆ–å…·æœ‰æ˜‚è´µå¤åˆ¶æ“ä½œçš„äº‹ç‰©æ¥è¯´æ˜¯å®‰å…¨çš„é»˜è®¤å€¼ã€‚ç„¶è€Œï¼Œå¯¹äºåƒå•ä¸ªæ•´æ•°æˆ–æµ®ç‚¹æ•°è¿™æ ·çš„å¾®å°äº‹ç‰©æ¥è¯´ï¼Œå®ƒçš„æ•ˆç‡å¾ˆä½ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒMojo å…è®¸ç»“æ„ä½“é€‰æ‹©åœ¨å¯„å­˜å™¨ä¸­ä¼ é€’ï¼Œè€Œä¸æ˜¯ä½¿ç”¨è£…é¥°å™¨é€šè¿‡å†…å­˜ä¼ é€’`@register_passable`ã€‚`Int`æ‚¨å°†åœ¨æ ‡å‡†åº“ä¸­çš„ç±»å‹ä¸Šçœ‹åˆ°æ­¤è£…é¥°å™¨ï¼š

```
@register_passable("trivial")
struct Int:
    var value: __mlir_type.`!pop.scalar<index>`

    fn __init__(value: __mlir_type.`!pop.scalar<index>`) -> Self:
        return Self {value: value}
    ...
```

åŸºæœ¬`@register_passable`è£…é¥°å™¨ä¸ä¼šæ”¹å˜ç±»å‹çš„åŸºæœ¬è¡Œä¸ºï¼šå®ƒä»ç„¶éœ€è¦æœ‰ä¸€ä¸ª`__copyinit__`å¯å¤åˆ¶çš„æ–¹æ³•ï¼Œå¯èƒ½ä»ç„¶æœ‰ä¸€ä¸ª`__init__`and`__del__`æ–¹æ³•ç­‰ã€‚è¿™ä¸ªè£…é¥°å™¨çš„ä¸»è¦å½±å“æ˜¯åœ¨å†…éƒ¨å®ç°ç»†èŠ‚ä¸Šï¼š`@register_passable`ç±»å‹é€šå¸¸æ˜¯ä¼ å…¥çš„æœºå™¨å¯„å­˜å™¨ï¼ˆå–å†³äºåº•å±‚æ¶æ„çš„è¯¦ç»†ä¿¡æ¯ï¼‰ã€‚

å¯¹äºå…¸å‹çš„ Mojo ç¨‹åºå‘˜æ¥è¯´ï¼Œè¿™ä¸ªè£…é¥°å™¨åªæœ‰ä¸€äº›å¯è§‚å¯Ÿåˆ°çš„æ•ˆæœï¼š

1. `@register_passable`ç±»å‹æ— æ³•ä¿å­˜ä¸æ˜¯å…¶æœ¬èº«çš„ç±»å‹çš„å®ä¾‹`@register_passable`ã€‚
2. ç±»å‹çš„å®ä¾‹`@register_passable`ä¸å…·æœ‰å¯é¢„æµ‹çš„æ ‡è¯†ï¼Œå› æ­¤`self`æŒ‡é’ˆä¸ç¨³å®š/ä¸å¯é¢„æµ‹ï¼ˆä¾‹å¦‚åœ¨å“ˆå¸Œè¡¨ä¸­ï¼‰ã€‚
3. `@register_passable`å‚æ•°å’Œç»“æœç›´æ¥æš´éœ²ç»™ C å’Œ C++ï¼Œè€Œä¸æ˜¯é€šè¿‡æŒ‡é’ˆä¼ é€’ã€‚
4. è¿™ç§ç±»å‹çš„å’Œæ–¹æ³•æ˜¯éšå¼é™æ€çš„ï¼ˆå°±åƒåœ¨ Python ä¸­ä¸€æ ·ï¼‰ï¼Œå¹¶æŒ‰å€¼è¿”å›å…¶ç»“æœè€Œä¸æ˜¯`__init__`é‡‡ç”¨ã€‚`__copyinit__``__new__``inout self`

æˆ‘ä»¬é¢„è®¡è¯¥è£…é¥°å™¨å°†æ™®éç”¨äºæ ¸å¿ƒæ ‡å‡†åº“ç±»å‹ï¼Œä½†å¯¹äºä¸€èˆ¬åº”ç”¨ç¨‹åºçº§ä»£ç å¯ä»¥å®‰å…¨åœ°å¿½ç•¥ã€‚

ä¸Šé¢çš„ä¾‹å­`Int`å®é™…ä¸Šä½¿ç”¨äº†è¿™ä¸ªè£…é¥°å™¨çš„â€œç®€å•â€å˜ä½“ã€‚å®ƒæ”¹å˜äº†å¦‚ä¸Šæ‰€è¿°çš„ä¼ é€’çº¦å®šï¼Œä½†ä¹Ÿä¸å…è®¸å¤åˆ¶å’Œç§»åŠ¨æ„é€ å‡½æ•°å’Œææ„å‡½æ•°ï¼ˆå°†å®ƒä»¬å…¨éƒ¨ç®€å•åœ°ç»¼åˆèµ·æ¥ï¼‰ã€‚

> TODOï¼šTrivial éœ€è¦ä¸å…¶è‡ªå·±çš„è£…é¥°å™¨è§£è€¦ï¼Œå› ä¸ºå®ƒä¹Ÿé€‚ç”¨äºå†…å­˜ç±»å‹ã€‚

### `@always_inline`è£…é¥°è€…[](#always_inline-decorator)

`@always_inline("nodebug")`ï¼šåŒæ ·çš„äº‹æƒ…ï¼Œä½†æ²¡æœ‰è°ƒè¯•ä¿¡æ¯ï¼Œå› æ­¤æ‚¨ä¸ä¼šè¿›å…¥ Int ä¸Šçš„ + æ–¹æ³•ã€‚

### `@parameter`è£…é¥°è€…[](#parameter-decorator)

è£…é¥°`@parameter`å™¨å¯ä»¥æ”¾ç½®åœ¨æ•è·è¿è¡Œæ—¶å€¼çš„åµŒå¥—å‡½æ•°ä¸Šï¼Œä»¥åˆ›å»ºâ€œå‚æ•°â€æ•è·é—­åŒ…ã€‚è¿™æ˜¯ Mojo ä¸­çš„ä¸€ä¸ªä¸å®‰å…¨åŠŸèƒ½ï¼Œå› ä¸ºæˆ‘ä»¬ç›®å‰æ²¡æœ‰å¯¹å¼•ç”¨æ•è·çš„ç”Ÿå‘½å‘¨æœŸè¿›è¡Œå»ºæ¨¡ã€‚æ­¤åŠŸèƒ½çš„ä¸€ä¸ªç‰¹æ®Šæ–¹é¢æ˜¯å®ƒå…è®¸æ•è·è¿è¡Œæ—¶å€¼çš„é—­åŒ…ä½œä¸ºå‚æ•°å€¼ä¼ é€’ã€‚

### é­”æœ¯å¸ˆ[](#magic-operators)

C++ ä»£ç æœ‰è®¸å¤šä¸å€¼ç”Ÿå‘½å‘¨æœŸç›¸äº¤çš„ç¥å¥‡è¿ç®—ç¬¦ï¼Œä¾‹å¦‚â€œplacement newâ€ã€â€œplacement deleteâ€å’Œâ€œoperator=â€ï¼Œå®ƒä»¬ä¼šåœ¨ç°æœ‰å€¼ä¸Šé‡æ–°åˆ†é…ã€‚å½“æ‚¨ä½¿ç”¨ Mojo çš„æ‰€æœ‰è¯­è¨€åŠŸèƒ½å¹¶åœ¨å®‰å…¨ç»“æ„ä¹‹ä¸Šè¿›è¡Œç»„åˆæ—¶ï¼ŒMojo æ˜¯ä¸€ç§å®‰å…¨è¯­è¨€ï¼Œä½†ä»»ä½•å †æ ˆéƒ½æ˜¯ C é£æ ¼æŒ‡é’ˆå’ŒçŒ–ç—çš„ä¸å®‰å…¨æ€§çš„ä¸–ç•Œã€‚Mojo æ˜¯ä¸€ç§å®ç”¨è¯­è¨€ï¼Œç”±äºæˆ‘ä»¬å¯¹ä¸ C/C++ äº’æ“ä½œä»¥åŠç›´æ¥åœ¨ Mojo æœ¬èº«ä¸­å®ç°å®‰å…¨ç»“æ„ï¼ˆå¦‚ Stringï¼‰æ„Ÿå…´è¶£ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥è¡¨è¾¾ä¸å®‰å…¨çš„äº‹ç‰©ã€‚

Mojo æ ‡å‡†åº“`Pointer[element_type]`ç±»å‹æ˜¯é€šè¿‡ MLIR ä¸­çš„åº•å±‚`!kgen.pointer<element_type>`ç±»å‹å®ç°çš„ï¼Œæˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ç§æ–¹æ³•åœ¨ Mojo ä¸­å®ç°è¿™äº›ä¸ C++ ç­‰æ•ˆçš„ä¸å®‰å…¨æ„é€ ã€‚æœ€ç»ˆï¼Œè¿™äº›å°†è¿ç§»åˆ° Pointer ç±»å‹ä¸Šçš„æ‰€æœ‰æ–¹æ³•ï¼Œä½†åœ¨æ­¤ä¹‹å‰ï¼Œæœ‰äº›éœ€è¦ä½œä¸ºå†…ç½®è¿ç®—ç¬¦å…¬å¼€ã€‚

### ç›´æ¥è®¿é—® MLIR[](#direct-access-to-mlir)

Mojo æä¾›å¯¹ MLIR æ–¹è¨€å’Œç”Ÿæ€ç³»ç»Ÿçš„å®Œå…¨è®¿é—®ã€‚è¯·æŸ¥çœ‹[Mojo ä¸­çš„ä½çº§ IRï¼Œ](https://docs.modular.com/mojo/notebooks/BoolMLIR.html)äº†è§£å¦‚ä½•ä½¿ç”¨`__mlir_type`ã€`__mlir_op`å’Œ`__mlir_type`ç»“æ„ã€‚æ‰€æœ‰å†…ç½®å’Œæ ‡å‡†åº“ API éƒ½æ˜¯é€šè¿‡è°ƒç”¨åº•å±‚ MLIR æ„é€ æ¥å®ç°çš„ï¼Œåœ¨è¿™æ ·åšæ—¶ï¼ŒMojo æœ‰æ•ˆåœ°å……å½“äº† MLIR ä¹‹ä¸Šçš„è¯­æ³•ç³–ã€‚
